<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ky0422 블로그</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Rust</li><li class="chapter-item expanded "><a href="rust/intro.html"><strong aria-hidden="true">2.</strong> 들어가기 앞서</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/beginner/index.html"><strong aria-hidden="true">2.1.</strong> Beginner</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/beginner/closure.html"><strong aria-hidden="true">2.1.1.</strong> Closure</a></li><li class="chapter-item expanded "><a href="rust/beginner/const.html"><strong aria-hidden="true">2.1.2.</strong> Constant</a></li><li class="chapter-item expanded "><a href="rust/beginner/default.html"><strong aria-hidden="true">2.1.3.</strong> Default</a></li><li class="chapter-item expanded "><a href="rust/beginner/cow.html"><strong aria-hidden="true">2.1.4.</strong> Cow</a></li><li class="chapter-item expanded "><a href="rust/beginner/hash.html"><strong aria-hidden="true">2.1.5.</strong> Hash, Hasher</a></li><li class="chapter-item expanded "><a href="rust/beginner/from.html"><strong aria-hidden="true">2.1.6.</strong> From, TryFrom</a></li><li class="chapter-item expanded "><a href="rust/beginner/inline.html"><strong aria-hidden="true">2.1.7.</strong> Inline Attribute</a></li><li class="chapter-item expanded "><a href="rust/beginner/static.html"><strong aria-hidden="true">2.1.8.</strong> Static Lifetime, Trait Bound</a></li></ol></li><li class="chapter-item expanded "><a href="rust/intermediate/index.html"><strong aria-hidden="true">2.2.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/intermediate/overloading.html"><strong aria-hidden="true">2.2.1.</strong> Function Overloading</a></li><li class="chapter-item expanded "><a href="rust/intermediate/bind.html"><strong aria-hidden="true">2.2.2.</strong> Monad Bind</a></li><li class="chapter-item expanded "><a href="rust/intermediate/marker.html"><strong aria-hidden="true">2.2.3.</strong> ?Trait, marker</a></li><li class="chapter-item expanded "><a href="rust/intermediate/any.html"><strong aria-hidden="true">2.2.4.</strong> Any</a></li><li class="chapter-item expanded "><a href="rust/intermediate/macro.html"><strong aria-hidden="true">2.2.5.</strong> Procedural Macro, Attribute</a></li><li class="chapter-item expanded "><a href="rust/intermediate/for.html"><strong aria-hidden="true">2.2.6.</strong> HRTB</a></li></ol></li><li class="chapter-item expanded "><a href="rust/advanced/index.html"><strong aria-hidden="true">2.3.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/advanced/pin.html"><strong aria-hidden="true">2.3.1.</strong> Pin</a></li><li class="chapter-item expanded "><a href="rust/advanced/rwlock.html"><strong aria-hidden="true">2.3.2.</strong> RwLock</a></li><li class="chapter-item expanded "><a href="rust/advanced/atomic.html"><strong aria-hidden="true">2.3.3.</strong> Atomic</a></li><li class="chapter-item expanded "><a href="rust/advanced/repr.html"><strong aria-hidden="true">2.3.4.</strong> Representation Attribute</a></li></ol></li><li class="chapter-item expanded "><a href="rust/lets_write/index.html"><strong aria-hidden="true">2.4.</strong> Let's write!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/lets_write/json.html"><strong aria-hidden="true">2.4.1.</strong> Any 트레잇을 사용해서 JSON 매크로 만들어보기</a></li></ol></li><li class="chapter-item expanded "><a href="rust/etc/index.html"><strong aria-hidden="true">2.5.</strong> 번외</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/etc/rust_vs_cpp.html"><strong aria-hidden="true">2.5.1.</strong> Rust가 C++를 대체할 수 있을까?</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">TypeScript</li><li class="chapter-item expanded "><a href="typescript/intro.html"><strong aria-hidden="true">3.</strong> 들어가기 앞서</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="note.html"><strong aria-hidden="true">4.</strong> 비고</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ky0422 블로그</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ky0422" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ky0422-블로그"><a class="header" href="#ky0422-블로그">ky0422 블로그</a></h1>
<p>Categories: <a href="./rust/intro.html"><code>Rust</code></a>, <a href="./typescript/intro.html"><code>TypeScript</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="들어가기-앞서"><a class="header" href="#들어가기-앞서">들어가기 앞서</a></h1>
<p>해당 Book은 Rust (러스트) 프로그래밍 언어의 중급 이상의 내용을 다루는 문서입니다. 이 Book은 가이드가 아닌, 참고 문서입니다. (각 문서는 별개임.)</p>
<p>Rust를 처음 접하는 분들은 <a href="https://doc.rust-lang.org/book/">Rust Book</a> (<a href="https://rinthel.github.io/rust-lang-book-ko/">한국어 번역</a>)을 먼저 읽어보시기 바랍니다.</p>
<p>목차는 크게 <code>Beginner</code> (초급), <code>Intermediate</code> (중급), <code>Advanced</code> (고급)으로 나뉘어져 있습니다. <code>Beginner</code>는 비교적 쉬운 내용을 다루고 있으며, <code>Intermediate</code> 및 <code>Advanced</code>는 Rust의 기본적인 내용을 이해하고 있는 분들을 대상으로 합니다.
또한, <code>Advanced</code>는 CS (Computer Science)의 기본적인 내용을 이해하고 있는 분들을 대상으로 합니다.</p>
<p><code>Let's write!</code>는 무언가를 만들어보는 과정입니다. 코드를 복사해도 되지만, 직접 작성해보는 것을 권장합니다.</p>
<h1 id="목차"><a class="header" href="#목차">목차</a></h1>
<ul>
<li>Beginner
<ul>
<li><a href="rust/./beginner/closure.html">클로저(<code>closure</code>)의 정체성</a></li>
<li><a href="rust/./beginner/const.html"><code>constant</code> (상수)와 <code>const fn</code></a></li>
<li><a href="rust/./beginner/default.html"><code>Default</code> 트레잇</a></li>
<li><a href="rust/./beginner/cow.html"><code>Cow&lt;T&gt;</code> 타입</a></li>
<li><a href="rust/./beginner/hash.html"><code>Hash</code> 트레잇, <code>Hasher</code>, <code>DefaultHasher</code></a></li>
<li><a href="rust/./beginner/from.html"><code>From</code>, <code>TryFrom</code> (Feat. <code>Into</code>, <code>TryInto</code>)</a></li>
<li><a href="rust/./beginner/inline.html"><code>#[inline]</code> 속성</a></li>
<li><a href="rust/./beginner/static.html"><code>&amp;'static T</code>와 <code>T: 'static</code>의 차이점</a></li>
</ul>
</li>
<li>Intermediate
<ul>
<li><a href="rust/./intermediate/overloading.html">함수 오버로딩 구현하기</a></li>
<li><a href="rust/./intermediate/bind.html">모나드 <code>bind</code> 함수 구현하기</a></li>
<li><a href="rust/./intermediate/marker.html"><code>?Trait</code> 바운드와 marker 타입</a></li>
<li><a href="rust/./intermediate/any.html"><code>Any</code> 트레잇과 <code>TypeId</code></a></li>
<li><a href="rust/./intermediate/macro.html">절차적 매크로, <code>syn</code>, <code>quote</code>, <code>Attribute</code> 만들기</a></li>
<li><a href="rust/./intermediate/for.html"><code>for&lt;'a&gt;</code> (상위 트레잇 바운드 <code>HRTB</code>)</a></li>
</ul>
</li>
<li>Advanced
<ul>
<li><a href="rust/./advanced/pin.html"><code>Pin</code>과 <code>Unpin</code></a></li>
<li><a href="rust/./advanced/rwlock.html"><code>RwLock</code>, 그리고 <code>Mutex</code>의 차이점</a></li>
<li><a href="rust/./advanced/atomic.html"><code>atomic</code> 타입과 <code>Ordering</code> 열거형 (feat. CPU 명령어 처리)</a></li>
<li><a href="rust/./advanced/repr.html"><code>repr</code> 속성 (feat. 메모리 정렬)</a></li>
</ul>
</li>
<li>Let's write!
<ul>
<li><a href="rust/./lets_write/json.html"><code>Any</code> 트레잇을 사용해서 <code>JSON</code> 비스무리한 매크로 만들기</a></li>
</ul>
</li>
<li>번외
<ul>
<li><a href="rust/./etc/rust_vs_cpp.html">Rust가 C++를 대체할 수 있을까?</a></li>
</ul>
</li>
<li>비고</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beginner"><a class="header" href="#beginner">Beginner</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="클로저closure의-정체성"><a class="header" href="#클로저closure의-정체성">클로저(closure)의 정체성</a></h1>
<p>클로저를 다루다 보면 이런 식의 에러 메시지가 발생할 때가 있습니다:</p>
<pre><code>...(...): [closure@src\...:n:n: x:xx]
</code></pre>
<p>보통 <code>integer</code>, <code>bool</code> 등의 타입 이름이 나오지만, 클로저는 위 형식과 같이 나옵니다.<br />
일단 이 상황은 잠시 미뤄둬봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut foo = vec![];
foo.push(|| 1);
foo.push(|| 2);
<span class="boring">}</span></code></pre></pre>
<p>당연히 작동할 것 같은 코드입니다만, 하지만 이 코드는 빌드되지 않습니다.</p>
<pre><code>mismatched types
expected closure `[closure@src\main.rs:4:14: 4:18]`
   found closure `[closure@src\main.rs:5:14: 5:18]`
no two closures, even if identical, have the same type
consider boxing your closure and/or using it as a trait object (rustc E0308)

main.rs(4, 14): the expected closure
main.rs(5, 9): arguments to this function are incorrect
mod.rs(1760, 12): associated function defined here
</code></pre>
<p>두 타입이 다르다는 오류가 우리를 반겨줍니다.<br />
<code>|| 1</code>과 <code>|| 2</code>는 분명 <code>fn() -&gt; i32</code> 타입인데, 두 타입이 다르다니 참 아이러니한 상황일겁니다.</p>
<p>그에 대한 해답은, 클로저의 내부적인 구조를 보면 이해가 될겁니다.<br />
rustc는 내부적으로 클로저를 각각 따로 구현합니다. 필자가 내부 구조를 알진 못하니, 일단 그렇게 알아둬봅시다.<br />
실제로 클로저의 <code>size_of_val</code>은 <code>0</code> 입니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = || 1;
println!(&quot;{}&quot;, size_of_val(&amp;x)); // 0

let y = 1;
println!(&quot;{}&quot;, size_of_val(&amp;y)); // 4

let z = String::from(&quot;hello&quot;);
println!(&quot;{}&quot;, size_of_val(&amp;z)); // 24

struct MyStruct;
println!(&quot;{}&quot;, size_of_val(&amp;MyStruct)); // 0
<span class="boring">}</span></code></pre></pre>
<p>이 문제는 <code>dyn</code>으로 명시해서 해결해봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;dyn Fn() -&gt; i32 = &amp;|| 1;
println!(&quot;{}&quot;, size_of_val(&amp;x)); // 16
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut foo: Vec&lt;&amp;dyn Fn() -&gt; i32&gt; = vec![];
foo.push(&amp;|| 1);
foo.push(&amp;|| 2);
<span class="boring">}</span></code></pre></pre>
<p>참고로 <code>dyn</code> (<code>dynamic</code>) 트레잇은 <code>Sized</code>가 아닌 타입(<code>?Sized</code>)입니다.
쉽게 말해, 컴파일 시간에 크기가 정해져 있지 않은 타입을 말합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constant-상수와-const-fn"><a class="header" href="#constant-상수와-const-fn">constant (상수)와 const fn</a></h1>
<p>러스트엔 <code>const</code> 키워드가 있습니다. 이름 그대로 상수 선언 키워드며, 얼핏 보면 <code>static item</code> 키워드와 비슷해 보입니다.
주제는 <code>const</code>이기 때문에 <code>static</code>의 간단한 설명과 차이점만 보고 넘어갑시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static STATIC: &amp;str = &quot;Hello, World!&quot;;
const CONSTANT: &amp;str = &quot;Hello, World!&quot;;
<span class="boring">}</span></code></pre></pre>
<p>둘 모두 <code>&amp;'static str</code> 타입을 가지는 전역 범위에서 사용할 수 있는 상수입니다.</p>
<ul>
<li><code>static</code>: 수명이 있으며, 가변(<code>mut</code>)이 가능한 변수 (이 경우 <code>unsafe</code> 코드로 값을 변경할 수 있습니다.)</li>
<li><code>const</code>: 변경 불가능. (어떤 일이 있어도 변경할 수 없는 값입니다.)</li>
</ul>
<p><code>const fn</code>는 <code>const</code> 상수처럼 <code>constant context</code>의 일부입니다. (<code>const impl</code> 등도 이에 포함됩니다.)</p>
<p>이들의 특징은 컴파일 타임 상수 평가자(<code>constant evaluation</code>)가 컴파일 타임에 표현식을 계산합니다.
또한 이들은 <code>for</code> 반복문 등을 허용하지 않습니다. (후술하겠지만, 사실 <code>for</code> 문 그 자체가 문제는 아닙니다.)
그런데 <code>while</code>이나 <code>loop</code> 반복문은 사용할 수 있습니다. 이는 <code>Iterator</code>의 <code>next</code> 함수 때문입니다.</p>
<p><code>for</code> 반복문은 <code>Iterator</code>의 <code>next</code>를 호출하여 순회합니다. 하지만 <code>const fn</code> 내부에선 <code>const fn</code>이 아닌 함수를 실행할 수 없습니다.
그렇기에 <code>for</code> 반복문을 사용할 수 없는 것이죠. 때문에 아래의 코드는 작동하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust">const fn foo() -&gt; i32 {
    let mut x = 0;
    loop { // work
        if x == 10 {
            break;
        }
        x += 1;
    }
    x
}

const fn bar() -&gt; i32 {
    for x in 0..10 { // &lt;- `for` is not allowed in a `const fn` ...
        if x == 10 {
            break;
        }
    }
}

const FOO: i32 = foo();
const BAR: i32 = bar();

fn main() {
    println!(&quot;{}&quot;, FOO);
    println!(&quot;{}&quot;, BAR);
}</code></pre></pre>
<h2 id="miri"><a class="header" href="#miri">miri</a></h2>
<p>추가로, 러스트의 <code>constant context</code>는 <a href="https://github.com/rust-lang/miri"><code>miri</code></a>라는 컴파일러 내장되어있는 인터프리터가 평가합니다.</p>
<p><code>miri</code>는 <code>Undefined Behavior</code> (<code>UB</code>) 가 일어나면 컴파일 에러를 띄워주기도 합니다.</p>
<p>평가가 완료되면 바이러니에 바이트채로 저장되어, <code>static</code> 등에 저장됩니다.
C++를 해보셨다면, <code>const fn</code>은 C++의 <code>constexpr</code>과 상당히 흡사하다는 걸 알 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-트레잇"><a class="header" href="#default-트레잇">Default 트레잇</a></h1>
<p><code>Default</code>로 구조체, 열거형 타입 등에서 기본 값을 가져올 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (a, b, c, d): (usize, bool, String, Vec&lt;i32&gt;) = Default::default();

assert_eq!(a, 0);
assert_eq!(b, false);
assert_eq!(c, &quot;&quot;);
assert_eq!(d, vec![]);
<span class="boring">}</span></code></pre></pre>
<p><code>Default</code> 트레잇을 구현하면 됩니다:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Foo {
    x: i32,
    y: i32,
}

impl Default for Foo {
    fn default() -&gt; Self {
        Foo { x: 0, y: 0 }
    }
}

fn main() {
    let foo = Foo::default();
    let foo: Foo = Default::default();

    assert_eq!(foo.x, 0);
    assert_eq!(foo.y, 0);
}</code></pre></pre>
<p>이렇게 구현된 <code>Default</code>는 <code>..</code>을 사용하여, 구현하지 않은 필드를 기본 값으로 채워줄 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo { x: 1, ..Foo::default() };
Foo { x: 1, ..Default::default() };
<span class="boring">}</span></code></pre></pre>
<p><code>&lt;Default를 구현한 타입&gt;::default()</code>, <code>Default::default()</code> 모두 같은 역할입니다.
단, <code>Default::default()</code>의 경우엔 위 코드처럼 타입 어노테이션을 붙여줘 하는 경우도 있습니다.</p>
<h2 id="열거형에서-default"><a class="header" href="#열거형에서-default">열거형에서 Default</a></h2>
<p>열거형(<code>enum</code>)의 경우엔 <code>Default</code> 트레잇 구현 없이 <code>#[default]</code> 속성(<code>attributes</code>)을 사용해 기본 값을 지정할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default, Debug)]
enum Foo {
    A,
    #[default]
    B,
}

fn main() {
    println!(&quot;{:?}&quot;, Foo::default());
}</code></pre></pre>
<p>단, 빈 아이템만 가능합니다. <code>B(String)</code> 같은 건 안된다는 소리죠. (내부적으로 <code>Default</code> 트레잇을 구현하기 때문에 불가능)</p>
<p>열거형의 아이템이 일급객체가 아니여서, 빈 아이템이 아니라면 <code>Default</code>를 적용하지 못한다고는 하지만, 개인적인 생각이긴하나 <code>Default</code> 매크로를 좀 건들면 해결될 문제라 생각합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cow-타입"><a class="header" href="#cow-타입">Cow<T> 타입</a></h1>
<p>우리는 어떤 값이 참조인가, 아니면 소유권을 가지고 있는가에 대해 코드상으로 알고 싶을 때가 있습니다.</p>
<p><code>std::borrow</code>에 존재하는 <code>ToOwned</code>라는 트레잇이 존재합니다.
<code>ToOwned</code>는 소유권이 있는 (<code>owned</code>) 타입으로 변환할 수 있는 트레잇입니다.</p>
<p>예를 들어, <code>to_owned</code> 함수를 사용하여, 참조 <code>&amp;str</code>를 소유권이 있는 <code>String</code>으로 변환할 수 있습니다.</p>
<p>이를 이용해서 구현하면 좋을 듯한데, 이미 구현된 게 있으니: 바로 Cow<T> (<a href="https://en.wikipedia.org/wiki/Copy-on-write">Copy On Write</a>) 열거형입니다.</p>
<blockquote>
<p><code>Copy On Write</code>는 읽기만 필요한 경우, 굳이 대상을 다시 쓸 필요가 없으며, 수정이 있다면 그 대상을 새로 만드는 리소스 관리 기법입니다. (이 때문에 크기가 커질 수 있습니다.)</p>
<p>즉, <code>Cow&lt;T&gt;</code>는 읽기 전용입니다.</p>
</blockquote>
<p><code>Cow&lt;T&gt;</code> 열거형의 구현은 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt;
where
    B: 'a + ToOwned + ?Sized,
 {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}</span></code></pre></pre>
<p>제네릭 <code>B</code>는 수명 <code>'a</code>, <code>ToOwned</code>와 <code>?Sized</code>로 바운드되어 있습니다.</p>
<blockquote>
<p><code>B</code>가 크기를 알 수 있는 타입인지 아닌지 모르니, <code>?Sized</code>가 포함되었습니다.</p>
</blockquote>
<p>예를 들어봅시다. <code>Borrowed</code>엔 <code>&quot;Hello, World!&quot;</code>, <code>&amp;'static str</code>가 포함될 수 있습니다.
반면 <code>String</code>은 <code>Owned</code>에 포함됩니다. 그 이유는, <code>ToOwned</code> 트레잇에 대해 <code>&amp;str</code>은 다음과 같이 구현되어 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ToOwned for str {
    type Owned = String;

    fn to_owned(&amp;self) -&gt; String {
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    fn clone_into(&amp;self, target: &amp;mut String) {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>연관 타입(<code>associated type</code>) <code>Owned</code>가 <code>String</code>으로 명시되어 있습니다.</p>
<p>즉, <code>String</code>은 <code>B</code> (<code>&amp;'static str</code>)의 <code>Owned</code>가 <code>String</code>이기 때문에, <code>String</code>은 <code>Owned</code>에 포함됩니다.</p>
<pre><pre class="playground"><code class="language-rust">use std::borrow::Cow;

fn foo(x: &amp;str) -&gt; Cow&lt;'static, str&gt; {
    if x == &quot;foo&quot; {
        Cow::Borrowed(&quot;bar&quot;)
    } else {
        Cow::Owned(x.to_string())
    }
}

fn main() {
    match foo(&quot;foo&quot;) {
        Cow::Borrowed(x /* &amp;str */) =&gt; println!(&quot;Borrowed: {x}&quot;),
        Cow::Owned(x /* String */) =&gt; println!(&quot;Owned: {x}&quot;),
    }

    match foo(&quot;baz&quot;) {
        Cow::Borrowed(x /* &amp;str */) =&gt; println!(&quot;Borrowed: {x}&quot;),
        Cow::Owned(x /* String */) =&gt; println!(&quot;Owned: {x}&quot;),
    }
}</code></pre></pre>
<p>이런 방법으로, 위에서 서술한 참조인가, 아니면 소유권을 가지고 있는 (<code>owned</code>) 값인가에 대해 알 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-트레잇-hasher-defaulthasher"><a class="header" href="#hash-트레잇-hasher-defaulthasher">Hash 트레잇, Hasher, DefaultHasher</a></h1>
<p>러스트 표준 라이브러리엔 해싱을 지원하는 모듈이 존재합니다. (<code>std::hash</code>)</p>
<p>말 그대로 해싱을 지원하며, 구조체에 <code>Hash</code> 트레잇을 사용할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">use std::{collections::hash_map::*, hash::*};

#[derive(Hash, Debug)]
struct Foo(usize);

fn hash&lt;T: Hash&gt;(t: &amp;T) -&gt; u64 {
    let mut hasher = DefaultHasher::new();
    t.hash(&amp;mut hasher);
    hasher.finish()
}

fn main() {
    let foo = Foo(30);
    println!(&quot;{:?}&quot;, hash(&amp;foo));

    let bar = Foo(30);
    println!(&quot;{:?}&quot;, hash(&amp;bar));
}</code></pre></pre>
<p>위 코드는 똑같은 <code>u64</code> 크기의 값을 출력합니다. 누가봐도 <code>Hash</code>의 모습이지만, 코드를 이해하는 것도 중요합니다.</p>
<p>먼저 위 코드는 다음과같이 작성할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 생략

#[derive(Debug)]
struct Foo(usize);

impl Hash for Foo {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.0.hash(state);
    }
}

// 생략
<span class="boring">}</span></code></pre></pre>
<p><code>#[derive(Hash)]</code> 는 내부적으로 위와 같이 구현됩니다. <code>Hasher</code>는 또 뭘까요?</p>
<h2 id="hasher"><a class="header" href="#hasher">Hasher</a></h2>
<p>말 그대로 해시하기 위한 트레잇입니다. 이 트레잇에는 <code>write_*</code>, <code>finish</code> 등의 메서드가 존재합니다.</p>
<p>실제로 위 코드에서 <code>finish</code>가 호출된것을 볼 수 있습니다. <code>Hasher</code>는 다음과 같이 작동합니다.</p>
<ol>
<li><code>DefaultHasher</code> 등으로 <code>Hasher</code>를 만듭니다.</li>
<li><code>write</code>, <code>write_*</code> (<code>write_u8</code>, <code>write_str</code> 등)을 호출하여 <code>Hasher</code>에 데이터를 씁니다.</li>
<li>finish로 마무리하여, 여태 썼던 해시를 반환합니다.</li>
</ol>
<p><code>DefaultHasher</code>는 <code>RandomState</code>을 사용합니다. 이 글에선 다루지 않으니, 궁금하다면 <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html">문서</a>를 참조하면 됩니다.</p>
<p>위에선 <code>write</code> 대신 <code>hash</code> 함수를 사용했는데, 이는 <code>Hash</code> 트레잇에 내장되어있습니다.</p>
<p><code>hash</code> 함수는 값을 해시하여, 가변 <code>Hasher</code> 참조에 <code>write</code> 합니다.
<code>Hash</code> 트레잇은 대부분의 기본 타입 (<code>str</code>, <code>char</code>, <code>u8</code>, <code>bool</code> 등)에 구현되어 있습니다.</p>
<p>만약 <code>sha256</code> 등의 다른 <code>Hasher</code>를 사용하고 싶다면, 다른 개발자가 만든 크레이트를 사용하면 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-tryfrom-feat-into-tryinto"><a class="header" href="#from-tryfrom-feat-into-tryinto">From, TryFrom (Feat. Into, TryInto)</a></h1>
<p><code>From</code> 트레잇을 사용하면, 다른 타입을 대상 타입으로 변환할 수 있습니다.</p>
<p>이미 많이 사용해왔던 기능인데, <code>String::from(&quot;foo&quot;)</code> 등으로 사용해왔던 트레잇입니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::*;

#[derive(Debug, PartialEq)]
struct Foo {
    bar: usize,
}

impl From&lt;usize&gt; for Foo {
    fn from(item: usize) -&gt; Self {
        Foo { bar: item }
    }
}

let x = Foo::from(5);
assert_eq!(x, Foo { bar: 5 });
<span class="boring">}</span></code></pre></pre>
<p>하지만 <code>Box&lt;T&gt;</code>같은 타입은 <code>new</code> 메서드를 사용해서 <code>Box</code>를 생성할 수 있습니다. (물론 <code>From</code> 트레잇도 구현되어 있으나, 둘 모두 같은 기능을 합니다.)</p>
<p>그럼 왜 굳이 <code>From</code> 트레잇을 구현하는가 하면, 매우 간단명료하게 대답할 수 있습니다:</p>
<p><code>Box</code>의 <code>new</code>와 <code>from</code>은 제네릭 <code>T</code>를 받고, <code>from</code>은 <code>new</code>를 호출한합니다.
(제네릭 <code>T</code>를 받지 않는 타입 (ex; <code>String</code>) 같은 경우, <code>new</code> 보단 <code>from</code>이 더욱 편합니다.)</p>
<p>그러므로 <code>new</code>와 <code>from</code> 메서드의 기능은 똑같지만, 후술할 <code>Into</code> 덕분에 <code>from</code>이 존재합니다.</p>
<h2 id="into"><a class="header" href="#into">Into</a></h2>
<p><code>Into</code>는 <code>From</code>을 구현하면 자동으로 구현됩니다. 다만, 사용 방법이 조금 다릅니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::*;

#[derive(Debug, PartialEq)]
struct Foo {
    bar: usize,
}

impl From&lt;usize&gt; for Foo {
    fn from(item: usize) -&gt; Self {
        Foo { bar: item }
    }
}

let x = Foo::from(5);
assert_eq!(x, Foo { bar: 5 });

let x: Foo = 5usize.into();
assert_eq!(x, Foo { bar: 5 });
<span class="boring">}</span></code></pre></pre>
<p><code>into</code>를 사용할 땐, 컴파일러가 어떤 타입인지 모르기 때문에, 타입 어노테이션을 명시해주어야 합니다.</p>
<h2 id="tryfrom-tryinto"><a class="header" href="#tryfrom-tryinto">TryFrom, TryInto</a></h2>
<p>관련 자료 등을 찾아보면 <code>TryFrom</code>과 <code>TryInto</code>가 존재하는 것을 알 수 있는데, 이들은 이름 그대로 반환되는 값이 <code>Result&lt;T, E&gt;</code>의 경우일 때 사용합니다.</p>
<p>대표적으로, 타입 변환을 사용할 때 이용됩니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Result&lt;i64, _&gt; = 5i32.try_into();
<span class="boring">}</span></code></pre></pre>
<p>타입으로 쓰인 <code>_</code>는 반환 값을 무시하는 <code>_ = expr;</code> 문법이 아닌, <a href="https://doc.rust-lang.org/reference/types/inferred.html"><code>infer</code> 타입을 뜻합니다.</a></p>
<p><code>TryFrom</code> 또한, <code>From</code> 트레잇과 비슷하게 구현할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::*;

#[derive(Debug, PartialEq)]
struct Foo {
    bar: usize,
}

impl TryFrom&lt;usize&gt; for Foo {
    type Error = &amp;'static str;

    fn try_from(value: usize) -&gt; Result&lt;Self, Self::Error&gt; {
        if value != 0 {
            Ok(Foo { bar: value })
        } else {
            Err(&quot;Error&quot;)
        }
    }
}

let x = Foo::try_from(5);
assert_eq!(x, Ok(Foo { bar: 5 }));

let x = Foo::try_from(0);
assert_eq!(x, Err(&quot;Error&quot;));

let _: Foo = 5usize.try_into().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>다만 차이점은, <code>Error</code>라는 연관 타입(associated type)이 존재하는데, 그냥 <code>Result&lt;T, E&gt;</code>의 제네릭 <code>E</code> 입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-속성"><a class="header" href="#inline-속성">#[inline] 속성</a></h1>
<p>일단 <code>inline</code> 함수가 무엇인지부터 알아봐야 합니다.</p>
<p>이는 본래 C/C++에서 유래되었는데, C/C++의 <code>inline</code>과 상당히 비슷합니다.
<code>inline</code> 함수의 작동 원리를 보기 전에, 일반적인 함수가 어떻게 작동하는지부터 알아봐야 하는데, 일반적으로 함수가 호출되면, 함수가 존재하는 코드로 점프하고, 실행이 끝나면 다시 원래 위치로 돌아옵니다.</p>
<p>여기서 <code>inline</code> 함수의 차이점이 들어납니다: <code>inline</code> 함수는 함수의 코드를 함수를 호출하는 부분에 복사합니다.
이는 매크로와 유사해보이는데, <code>inline</code> 함수는 개발자 입장에서 일반적인 함수와 똑같습니다만, 내부적으론 다릅니다.</p>
<p>물론 <code>inline</code> 함수를 많이 사용하는 것은 오히려 독이 될 수 있습니다: 많은 <code>inline</code> 함수를 호출하면, 그 많은 코드가 복사된다는 뜻이고, 이는 곧 느려질 수 있다는 뜻이죠.</p>
<p>그럼 이 <code>inline</code> 함수는 언제 써야 할까요? 사실 개발자가 직접 <code>inline</code>을 명시해주는 것은 그다지 좋은 선택이 아닙니다.</p>
<p>러스트 컴파일러는 알아서 <code>inline</code>을 사용할지 말지 결정합니다.
이 부분에 대해선 우리보다 컴파일러가 더 똑똑하니, 굳이 명시해줄 필요는 없습니다.</p>
<h2 id="그래도-굳이-쓰고싶다면-"><a class="header" href="#그래도-굳이-쓰고싶다면-">그래도 굳이 쓰고싶다면 ...</a></h2>
<p>러스트엔 <code>inline</code> 함수를 명시해주는 속성이 있습니다: <code>#[inline(..)]</code></p>
<p>크게 <code>#[inline]</code>, <code>#[inline(always)]</code> 그리고 <code>#[inline(never)]</code>가 존재하는데, 각각 하는 일은 다음과 같습니다:</p>
<ul>
<li><code>#[inline]</code>: inline 함수가 되어야 함을 명시합니다. 항상 <code>inline</code> 되는 것은 아닌데, 이 또한 컴파일러가 결정합니다.</li>
<li><code>#[inline(always)]</code>: <code>#[inline]</code> 보다 더 강력하게 <code>inline</code> 함수가 되어야 함을 명시합니다. 물론 항상 inline 함수가 되진 않습니다.</li>
<li><code>#[inline(never)]</code>: inline 함수가 되면 안된다는 것을 명시합니다.</li>
</ul>
<p>이러한 <code>#[inline]</code> 속성은 <code>new</code>와 같은 함수같은 단순한 함수에 주로 사용됩니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo(u8);

impl Foo {
    #[inline]
    fn new(x: u8) -&gt; Self {
        Foo(x)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-t와-t-static의-차이점"><a class="header" href="#static-t와-t-static의-차이점">&amp;'static T와 T: 'static의 차이점</a></h1>
<p>특히 러스트 초보(= 입문자)분들이 흔히들 오해를 하는데, 이 둘은 생긴것만 비슷하게 생겼고, 동작은 다릅니다.</p>
<p><code>&amp;'static T</code>는 참조의 정적 수명입니다. 이 글을 방문했다는건 정적 수명에 대해 대부분 알고있을거라 생각합니다.</p>
<p>이름이 비슷한 <code>T: 'static</code>은 트레잇 바운드입니다.</p>
<p>이것은 <code>T</code>가 정적 라이프타임을 가지고 있지 않으면, 제한하는 트레잇 바운드입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;T: 'static&gt;(_x: T) {}

static X: i32 = 5;

fn main() {
    let x: &amp;'static str = &quot;Hello, World!&quot;;
    foo(x);
    foo(X);

    let y = 5;
    foo(&amp;y); // error
}</code></pre></pre>
<p>이 코드에서 <code>x</code>와 <code>X</code>는 <code>'static</code> 수명을 가지기 때문에, 아무런 문제가 없었습니다.</p>
<p>반면 <code>y</code>의 참조는 <code>'static</code> 수명을 가지고 있지 않기 때문에, 오류가 발생합니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p><code>&amp;'static T</code>와 <code>T: 'static</code>은 다르며, 전자는 정적 수명을 가짐을 명시, 후자는 정적 수명을 가지고 있지 않으면 그것을 제한하는 트레잇 바운드입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="함수-오버로딩-구현하기"><a class="header" href="#함수-오버로딩-구현하기">함수 오버로딩 구현하기</a></h1>
<p>유감스럽게도 러스트엔 함수 오버로딩(<code>overloading</code>), <code>default parameter</code>, <code>optional parameter</code> 등이 없습니다.
하지만 오버로딩은 대충 구현해볼 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Overloading;

trait Foo&lt;T&gt; {
    type Output;
    fn ctor(arg: T) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>이렇게 선언된 구조체와 트레잇을 이용하여 함수 오버로딩을 사용할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo&lt;usize&gt; for Overloading {
    type Output = usize;

    fn ctor(arg: usize) -&gt; Self::Output {
        arg * 10
    }
}

impl Foo&lt;String&gt; for Overloading {
    type Output = String;

    fn ctor(arg: String) -&gt; Self::Output {
        arg + &quot;!&quot;
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>ctor</code>은 <code>constructor</code>를 의미합니다. 이 예제에선 <code>ctor</code> 라는 네이밍을 사용했습니다.</p>
</blockquote>
<p>이런 식으로 제네릭 <code>T</code>엔 인자 타입, 연관 타입(associated type) <code>Output</code>을 구현하여, 오버로딩을 흉내 낼 수 있습니다.
이제 헬퍼(Helper) 함수를 이용해서 편리하게 호출할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">#[inline]
fn foo&lt;T&gt;(arg: T) -&gt; &lt;Overloading as Foo&lt;T&gt;&gt;::Output
where
    Overloading: Foo&lt;T&gt;,
{
    &lt;Overloading as Foo&lt;T&gt;&gt;::ctor(arg)
}

fn main() {
    println!(&quot;{}&quot;, foo(2));
    println!(&quot;{}&quot;, foo(String::from(&quot;Hello&quot;)));
}</code></pre></pre>
<p>번외로, 여기서 <code>#[inline]</code> 속성이 사용되었습니다. 이에 대한 글은 <a href="https://ky0422.tistory.com/24">이곳</a>을 참고해봅시다.</p>
<p>다만 복수 개의 인자를 받을 수는 없습니다. 그럴땐 튜플을 사용하거나 매크로를 사용해봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo&lt;(usize, usize)&gt; for Overloading {
    type Output = usize;

    fn ctor(arg: (usize, usize)) -&gt; Self::Output {
        arg.0 + arg.1
    }
}

println!(&quot;{}&quot;, foo((2, 3)));
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($arg:expr) =&gt; {
        $arg * 10
    };
    ($a:expr, $b:expr) =&gt; {
        $a + $b
    };
}

assert_eq!(foo!(2), foo!(15, 5));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="모나드-bind-함수-구현하기"><a class="header" href="#모나드-bind-함수-구현하기">모나드 bind 함수 구현하기</a></h1>
<p>먼저 모나드가 뭔지 모른다면, <a href="https://www.google.com/search?q=Monad&amp;oq=Monad">구글링을 해보도록 합시다.</a><br />
금붕어도 이해할 만큼 쉽게 설명하면, <code>Option&lt;T&gt;</code>, <code>Result&lt;T, E&gt;</code> 같은게 모나드입니다.</p>
<p>자세한건 생략하겠지만, 물론 이게 모나드의 전부가 아닙니다.
사실 필자도 모나드에 대해서 자세하게 아는건 아닙니다.
이 글에선 모나드의 강력한 기능중 하나인 <code>bind</code> (하스켈에선 <code>&gt;&gt;=</code> 연산자) 를 구현해보고자 합니다.</p>
<p>러슬람들은 트레잇을 참 좋아합니다. 트레잇을 선언하고, 그 트레잇을 구현해봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Monad {
    type T;
    type U;

    fn bind&lt;F&gt;(self, f: F) -&gt; Self::U
    where
        F: FnOnce(Self::T) -&gt; Self::U;
}
<span class="boring">}</span></code></pre></pre>
<p><code>type T</code>는 <code>bind</code>의 인자가 받는 함수(<code>f</code>)의 인자이며, <code>type U</code>는 <code>bind</code>와 <code>f</code>의 반환값입니다.<br />
이렇게만 말하면 뭔말인지 이해가 힘드니, 직접 구현해보며 이해해봅시다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Monad for Option&lt;T&gt; {
    type T = T;
    type U = Option&lt;T&gt;;

    fn bind&lt;F&gt;(self, f: F) -&gt; Self::U
    where
        F: FnOnce(Self::T) -&gt; Self::U,
    {
        match self {
            Some(x) =&gt; f(x),
            None =&gt; None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code>에 대한 <code>Monad</code> 구현입니다. <code>bind</code> 함수를 봅시다.<br />
만약 <code>self</code> (<code>Option&lt;T&gt;</code>)가 <code>Some&lt;T&gt;</code> 이면, 함수 <code>f</code>를 실행하며, 아니라면 그냥 <code>None</code>을 반환합니다.</p>
<p>이제 한층 더 편한 러스트 프로그래밍을 할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(Some(10).bind(|x| Some(x * 10)), Some(100));
assert_eq!(None::&lt;usize&gt;.bind(|x| Some(x * 10)), None);

let (mul_5, div_10) = (|x: usize| Some(x * 5), |x: usize| Some(x / 10));

assert_eq!(Some(10).bind(mul_5).bind(div_10), Some(5));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-바운드와-marker-타입"><a class="header" href="#trait-바운드와-marker-타입">?Trait 바운드와 marker 타입</a></h1>
<p><code>?</code> (물음표) 트레잇 바운드는 트레잇이 선택 사항임을 표시하는 문법입니다.</p>
<pre><pre class="playground"><code class="language-rust">trait X {}

struct A;
impl X for A {}
struct B;

fn foo&lt;T&gt;(_x: T)
where
    T: ?X {}

fn main() {
    foo(A);
    foo(B);
}</code></pre></pre>
<p>만약 <code>T: ?X</code>가 아닌, <code>T: X</code> 였다면, 오류가 발생했을 것입니다:</p>
<pre><code>the trait bound `B: X` is not satisfied
the trait `X` is implemented for `A`
</code></pre>
<p>보통 <code>?Sized</code>등의 <code>marker 타입</code>으로 <code>?</code> 트레잇 바운드를 사용해보았을 겁니다:</p>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;T&gt;(x: &amp;T)
where
    T: ?Sized + std::fmt::Debug,
{
    println!(&quot;{x:?}&quot;);
}

fn main() {
    let x = 42;
    foo(&amp;x);
}</code></pre></pre>
<p><code>Sized</code>는 컴파일 타임에 알려진 크기의 타입입니다.
예를 들어 <code>[usize; 3]</code>은 크기가 <code>3</code>이라는 알려진 타입입니다.
하지만 <code>[usize]</code>는 컴파일 타입에 길이가 얼만지 모릅니다.</p>
<blockquote>
<p>보통 <code>str</code> 이나 <code>[T]</code> 등의 알려지지 않은 크기의 타입을 <code>DST</code> (<code>Dynamically Sized Type</code>)이라고 부릅니다.</p>
</blockquote>
<p>이럴 때 <code>?Sized</code>를 사용하여 컴파일 타임에 알려지지 않은 크기의 타입을 취급할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt;(T)
where
    T: ?Sized + std::fmt::Debug;

struct FooBar(Foo&lt;[usize]&gt;);
<span class="boring">}</span></code></pre></pre>
<p>아까부터 <code>marker 타입</code>이 언급됐습니다.</p>
<h2 id="요약-1"><a class="header" href="#요약-1">요약</a></h2>
<p><code>marker 타입</code>은 정말 간단하게 말해서, 어떤 타입의 속성을 나타내는 구조체, 트레잇 등의 빈 타입입니다.
러스트의 타입은 고유한 속성에 따라, 다양한 방식으로 분류됩니다.</p>
<p>그러한 속성을 표시(명시)해주는 타입입니다.
위에서 언급한 <code>Sized</code>도 <code>marker</code> 타입이며, 구조체로 이루어진 <code>PhantomData</code>, <code>PhantomPinned</code>, 트레잇으로 이루어진 <code>Copy</code>, <code>Send</code>, <code>Sync</code>, <code>Sized</code>, <code>Unpin</code>도 <code>marker 타입</code>입니다. (자세한 사항은 <a href="https://doc.rust-lang.org/std/marker/index.html">여기</a>에서 확인할 수 있습니다.)</p>
<p>위 <code>?</code> 트레잇 바운드와 반대로, 부정 트레잇 바운드도 존재합니다: <code>!</code> (느낌표)
이가 대표적으로 사용되는 예는 <code>Rc&lt;T&gt;</code> 입니다.
<code>Rc&lt;T&gt;</code>에서는 <code>Send</code>와 <code>Sync</code>을 구현하면 안 됩니다. (자칫하다간 데이터 레이스가 발생할 수 있기 때문)
때문에 <code>Rc&lt;T&gt;</code>의 구현을 보면</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; !Send for Rc&lt;T&gt; where T: ?Sized { /* ... */ }
impl&lt;T&gt; !Sync for Rc&lt;T&gt; where T: ?Sized { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>처럼 구현된 것을 볼 수 있습니다. 반면 <code>Arc</code>의 구현을 보면 <code>Send</code>와 <code>Sync</code>이 구현되어 있는 것을 확인할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Send for Arc&lt;T&gt;
where
    T: Sync + Send + ?Sized { /* ... */ }

impl&lt;T&gt; Sync for Arc&lt;T&gt;
where
    T: Sync + Send + ?Sized { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="any-트레잇과-typeid"><a class="header" href="#any-트레잇과-typeid">Any 트레잇과 TypeId</a></h1>
<p><code>Any</code> 트레잇은 모든 <code>'static</code> 타입의 동적 타이핑을 가능케 하는 트레잇입니다.
<code>'static</code>은 수명 <code>'static</code>과 트레잇 바운드 <code>'static</code>이 존재합니다. 자세한 내용은 <a href="https://ky0422.tistory.com/25">이 글</a>을 참고해봅시다.
여기서 서술하는 <code>'static</code>은 트레잇 바운드 <code>'static</code>을 의미합니다.</p>
<p><code>Any</code> 타입을 사용하는 예제:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::any::Any;

let x: Box&lt;dyn Any&gt; = Box::new(1);
let y: &amp;dyn Any = &amp;1;
<span class="boring">}</span></code></pre></pre>
<p><code>Any</code>는 컴파일 타임에 크기를 알 수 없습니다. 때문에 <code>dyn</code> 접두사를 사용하며, <code>Box</code> 또는 <code>'static</code> 참조를 사용합니다.
<code>Any</code> 타입을 사용하는 다른 예제:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{any::Any, fmt::Display};

fn foo&lt;T: Any + Display&gt;(x: &amp;T) {
    match (x as &amp;dyn Any).downcast_ref::&lt;i32&gt;() {
        Some(v) =&gt; println!(&quot;i32: {v}&quot;),
        None =&gt; println!(&quot;unknown: {x}&quot;),
    }
}

foo(&amp;1);
foo(&amp;&quot;hello&quot;);
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>downcast_ref</code>를 사용하였습니다.</p>
<p><code>downcast_mut</code> 등의 여러 API가 존재하는데, 각자 하는 역할은 다음과 같습니다:</p>
<ul>
<li><code>downcast&lt;T&gt;</code>: 이는 <code>Box&lt;...&gt;</code>에 대해 구현되어 있습니다. <code>Box</code>를 <code>downcast</code> 하며, <code>Result&lt;T, E&gt;</code>를 반환합니다.</li>
<li><code>downcast_ref&lt;T&gt;</code>: <code>dyn Any</code> + <code>'static</code>에 구현되어 있습니다. 내부 값이 <code>T</code> 타입과 일치한다면, 그것에 대해 참조를 반환합니다. <code>Option&lt;T&gt;</code>를 반환하며, 일치하지 않다면 <code>None</code>을 반환합니다.</li>
<li><code>downcast_mut&lt;T&gt;</code>: 위 <code>downcast_ref</code>와 동일하며, 가변 참조를 반환합니다.</li>
</ul>
<p>이밖에도 <code>is</code> 함수 등이 구현되어 있지만, 이 글에선 서술하지 않습니다. 자세한 내용은 <a href="https://doc.rust-lang.org/std/any/trait.Any.html">이곳</a>을 참고해봅시다.</p>
<h2 id="typeid"><a class="header" href="#typeid">TypeId</a></h2>
<p><code>TypeId</code>는 타입에 대해 고유한 식별자를 나타냅니다. 위에서 서술하진 않았지만, 타입을 비교하는 <code>is</code> 함수는 다음과 같이 정의되어 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is&lt;T: Any&gt;(&amp;self) -&gt; bool {
    let t = TypeId::of::&lt;T&gt;();

    let concrete = self.type_id();

    t == concrete
}
<span class="boring">}</span></code></pre></pre>
<p>대충 보면 <code>is</code>의 사용 방법을 알 것입니다. 하지만 <code>is</code>의 사용 방법을 서술하진 않았으니, <code>TypeId</code> 부분을 봅시다.
<code>Any</code> 트레잇은 <code>TypeId</code>를 반환하는 <code>type_id</code>라고 하는 함수를 구현하고 있습니다.</p>
<p>위는 <code>TypeId::of::&lt;T&gt;()</code>를 사용하여, 두 <code>TypeId</code>가 일치하는지 검사하는 함수입니다.
사실상 <code>TypeId</code>의 주요 기능은 이게 전부입니다.</p>
<p>이밖에도 <code>Provider</code>와 <code>Demand</code>가 존재하지만 깊이 들어가는 기능이기도 하고, 무엇보다 실험적 기능이므로 이 글에선 서술하지 않습니다.
혹시라도 궁금하다면 <a href="https://doc.rust-lang.org/nightly/std/any/index.html#provider-and-demand">이곳</a>을 참고해봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="절차적-매크로-syn-quote-attribute"><a class="header" href="#절차적-매크로-syn-quote-attribute">절차적 매크로, syn, quote, Attribute</a></h1>
<p>절차적 매크로는 함수(<code>procedure</code>)처럼 생겼다고 해서 절차적 매크로(<code>procedural macro</code>)입니다.</p>
<p><code>#[foo(bar = 10)]</code> 등의 모습은 속성이며, 이는 Attribute (속성) 문법입니다. 여기서 만들 절차적 매크로는 <code>#[derive(Foo)]</code> 등의 <code>Derive</code> 속성입니다.</p>
<p>일반적인 매크로와의 차이점이라 하면, 일반적인 매크로는 패턴에 맞게 대치하는 반면, 절차적 매크로는 코드를 추가합니다.</p>
<p>절차적 매크로를 만들기위해, <code>proc-macro</code> (절차적 매크로) 크레이트를 생성해줍니다.</p>
<blockquote>
<p>왜 따로 절차적 매크로 크레이트를 분리해야 하냐는 질문이 분명 있을 겁니다:</p>
<p>절차적 매크로 크레이트는 일반적인 크레이트처럼 생겼지만, 컴파일 시 문법 (AST 등)를 수정한다는 점에서, 일반적인 크레이트 보단 컴파일러 플러그인 정도에 가깝습니다.</p>
<p>이에 대해 한 가지 더 재밌는 사실을 알 수 있는데, 절차적 매크로 크레이트는, 빌드 시 절차적 매크로가 아닌 크레이트들과 연결되지 않습니다. 때문에, 굳이 타겟 아키텍처에 맞게 빌드할 필요는 없습니다.</p>
</blockquote>
<p>오늘의 예제 프로젝트 구조는 다음과 같습니다.<br />
(예제를 무시하고 절차적 매크로 선언만 보고 싶다면, 무시해도 괜찮습니다.):</p>
<ul>
<li><code>/foo</code> 크레이트
<ul>
<li>``/src`
<ul>
<li><code>main.rs</code></li>
</ul>
</li>
<li><code>Cargo.toml</code></li>
</ul>
</li>
<li><code>/foo_derive</code> (절차적 매크로 크레이트)
<ul>
<li><code>/src</code>
<ul>
<li><code>lib.rs</code></li>
</ul>
</li>
<li><code>Cargo.toml</code></li>
</ul>
</li>
</ul>
<p>먼저 아래의 명령어를 입력하여, 크레이트를 생성해줍니다.:</p>
<pre><code class="language-console">$ cargo new foo --bin
$ cargo new foo_derive --lib
</code></pre>
<p><code>foo</code> 크레이트의 <code>Cargo.toml</code>에서 <code>foo_derive</code> 의존성을 추가해주어야 합니다:</p>
<pre><code class="language-toml">[dependencies]
foo_derive = { path = &quot;../foo_derive&quot; }
</code></pre>
<p>또한, 절차적 매크로는 <code>proc-macro</code>를 따로 추가해주어야 합니다. <code>foo_derive</code> 크레이트의 <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># 생략

[lib]
proc-macro = true
</code></pre>
<p><code>rust analyzer</code> 등을 사용한다면, <code>foo_derive</code> 크레이트에서 오류가 발생할 것입니다. 이는 매우 정상적이며, 절차적 매크로 크레이트에선 절차적 매크로만 선언되어야 합니다.</p>
<h2 id="syn과-quote"><a class="header" href="#syn과-quote">syn과 quote</a></h2>
<p>그리고 몇 가지의 크레이트가 더 필요한데, <code>syn</code> 크레이트와 <code>quote</code> 크레이트가 필요합니다. 각각의 크레이트가 하는 일은 다음과 같습니다:</p>
<ul>
<li><a href="https://docs.rs/syn/latest/syn/"><code>syn</code></a>: <code>TokenStream</code>을 분석합니다. 또한, 우리가 러스트 코드에서 사용할 수 있는 AST 관련 데이터 등을 제공합니다.</li>
<li><a href="https://docs.rs/quote/latest/quote/"><code>quote</code></a>: 러스트 코드를 받아, <code>TokenStream</code>으로 반환합니다.</li>
</ul>
<p>각 크레이트에 대해 자세히 알고 싶다면, 각 크레이트의 문서를 참고하길 바랍니다.</p>
<p>필자는 현재의 최신 버전인 <code>syn 1.0.102</code>, <code>quote 1.0.21</code>를 사용합니다:</p>
<pre><code class="language-toml">[dependencies]
quote = &quot;1.0.21&quot;
syn = &quot;1.0.102&quot;
</code></pre>
<p>이제 준비는 끝났습니다. 절차적 매크로 선언은 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;

#[proc_macro_derive(FooMacro)]
pub fn foo_macro(input: TokenStream) -&gt; TokenStream {
    input
}
<span class="boring">}</span></code></pre></pre>
<p>이 아직 코드는 무의미합니다. 이제 아까 추가해두었던 <code>syn</code>과 <code>quote</code>를 사용해봅시다.
우리가 만들 절차적 매크로는, <code>FooMacro</code>를 호출하면 <code>Person</code> 트레잇을 구현해주는 절차적 매크로입니다.</p>
<p><code>foo</code> 크레이트의 <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use foo_derive::FooMacro;

trait Person {
    fn say_hello(&amp;self);
}

#[derive(FooMacro)]
struct A {
    name: String,
}

fn main() {
    let a = A {
        name: &quot;John&quot;.to_string(),
    };
    a.say_hello();
}</code></pre></pre>
<p>이제 <code>syn</code>과 <code>quote</code> 크레이트가 필요합니다. <code>syn</code>의 <code>parse_macro_input</code> 매크로를 이용해서, <code>TokenStream</code>을 분석합니다:</p>
<p><code>foo_derive</code> 크레이트의 <code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(FooMacro)]
pub fn foo_macro(input: TokenStream) -&gt; TokenStream {
    let DeriveInput { ident, .. } = parse_macro_input!(input as DeriveInput);

    let result = quote! {
        impl Person for #ident {
            fn say_hello(&amp;self) {
                println!(&quot;Hello, my name is {}&quot;, self.name);
            }
        }
    };

    result.into()
}
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>DeriveInput</code> 구조체는 다음과 같은 필드가 존재합니다:</p>
<ul>
<li><code>attrs</code>: <code>#[foo]</code> 같은 속성을 뜻합니다.</li>
<li><code>vis</code>: <code>pub</code>, <code>pub(crate)</code> 같은 가시성을 뜻합니다.</li>
<li><code>ident</code>: 그 아이템의 <code>identifier</code> (식별자)를 뜻합니다.</li>
<li><code>generics</code>: 제네릭 또는 <code>where</code> 절을 뜻합니다.</li>
<li><code>data:</code> 구조체의 경우 필드 등을 뜻합니다. (<code>struct</code>, <code>enum</code>, <code>union</code>)</li>
</ul>
<p>여기서 우리가 사용한 것은 <code>ident</code> 입니다.</p>
<p>그리고 우리는 <code>quote</code> 크레이트를 사용하여, <code>quote</code> 매크로를 호출했습니다.</p>
<p>만약 <code>quote</code> 크레이트 없었다면, 우리는 직접 AST를 하나하나 구현했어야 했을 겁니다.
다행히 <code>quote! {}</code> 매크로는 <code>TokenStream</code>을 반환하므로, <code>into</code>를 호출하여 반환한다.</p>
<p>이제 <code>foo</code> 크레이트를 실행하면, 성공적으로 <code>&quot;Hello, my name is John&quot;</code> 이 출력되었을 것입니다.
예상했겠지만, <code>Debug</code>, <code>Default</code> 등의 매크로도 위와 같은 원리입니다. (물론 이들은 <code>built-in</code>이긴 합니다만)</p>
<p>실제로 <code>Debug</code>의 예시로, 아래의 둘 모두 똑같이 작동합니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Foo {
    bar: usize
}
<span class="boring">}</span></code></pre></pre>
<p>만약, <code>Debug</code> 매크로가 없었다면, 우리는 아래와 같이 일일이 구현해주었어야 할 것입니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    bar: usize,
}

impl std::fmt::Debug for Foo {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.debug_struct(&quot;Foo&quot;).field(&quot;bar&quot;, &amp;self.bar).finish()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>아까 우리는 <code>DeriveInput</code>에서 <code>attrs</code>가 존재하는 것을 확인했습니다.</p>
<p>속성(<code>attrs</code>)을 손수 만들어보고 싶은데, <code>syn</code>만 이용해선 힘들 겁니다.</p>
<p>이제, <code>darling</code> 크레이트를 사용해봅시다.</p>
<h2 id="darling"><a class="header" href="#darling">darling</a></h2>
<p>그리 유명한 크레이트는 아니나, <code>darling</code> 크레이트는 속성을 쉽게 파싱 할 수 있는 유용한 크레이트입니다.</p>
<p>필자는 가장 최신 버전인 <code>0.14.1</code>을 사용했습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
darling = &quot;0.14.1&quot;
quote = &quot;1.0.21&quot;
syn = &quot;1.0.102&quot;
<span class="boring">}</span></code></pre></pre>
<p><code>darling</code> 크레이트는 <code>FromDeriveInput</code> 절차적 매크로와, 그에 따른 <code>darling</code> 속성을 이용하여, <code>attrs</code>를 파싱 할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use darling::FromDeriveInput;
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[derive(FromDeriveInput, Default)]
#[darling(default, attributes(nickname))]
struct Attributes {
    nickname: Option&lt;String&gt;,
}

#[proc_macro_derive(FooMacro, attributes(nickname))]
pub fn foo_macro(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let attrs = Attributes::from_derive_input(&amp;input).unwrap();

    let DeriveInput { ident, .. } = input;

    let my_name = match attrs.nickname {
        Some(nickname) =&gt; quote! {
            fn say_hello(&amp;self) {
                println!(&quot;Hello, my name is {}, but you can call me {}.&quot;, self.name, #nickname);
            }
        },
        None =&gt; quote! {
            fn say_hello(&amp;self) {
                println!(&quot;Hello, my name is {}.&quot;, self.name);
            }
        },
    };

    let result = quote! {
        impl Person for #ident {
<span class="boring">            my_name
</span>        }
    };

    result.into()
}
<span class="boring">}</span></code></pre></pre>
<p>코드가 좀 복잡해졌습니다. 하지만 수정하기 전의 코드에서 조금의 코드만 추가되었을 뿐입니다.</p>
<p><code>FromDeriveInput</code>를 사용했다면, <code>proc_macro_derive</code> 속성에도 <code>attributes</code>를 추가하여 이런 하위 속성이 있다고 명시해주어야 합니다.</p>
<p>그런데 만약 <code>Attributes</code>에서 <code>Option&lt;T&gt;</code>를 사용하지 않으면 어떻게 될까요?</p>
<p>눈치가 빠른 독자라면 <code>Default</code> 트레잇이 적용되었기 때문에, 빈 문자열이 반환됩니다. 이것을 방지하기 위해, <code>Option&lt;T&gt;</code>를 사용했습니다. 생각하지 못했다고 실망하진 맙시다.</p>
<p>이제 다음과 같은 코드가 가능해졌습니다:</p>
<pre><pre class="playground"><code class="language-rust">use foo_derive::FooMacro;

trait Person {
    fn say_hello(&amp;self);
}

#[derive(FooMacro)]
struct A {
    name: String,
}

#[derive(FooMacro)]
#[nickname(nickname = &quot;Bob&quot;)]
struct B {
    name: String,
}

fn main() {
    let a = A {
        name: &quot;John&quot;.to_string(),
    };
    a.say_hello();

    let b = B {
        name: &quot;John&quot;.to_string(),
    };
    b.say_hello();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fora-상위-트레잇-바운드-hrtb"><a class="header" href="#fora-상위-트레잇-바운드-hrtb">for&lt;'a&gt; (상위 트레잇 바운드 HRTB)</a></h1>
<p>들어가기 앞서, 참고로 여기서 <code>for</code>은 반복문 또는 트레잇 구현 키워드가 아닙니다.</p>
<p><code>Higher Rank Trait Bounds</code> (<code>HRTB</code>) 키워드입니다.<br />
한국어로 직역하면 상위 트레잇 바운드인데, 일단 이는 잠시 저장해두고 아래의 예제를 보도록 합시다.</p>
<pre><pre class="playground"><code class="language-rust">trait Foo&lt;F&gt; {
    fn foo(&amp;self, f: F) -&gt; &amp;usize;
}

struct Bar((usize, usize));

impl&lt;T&gt; Foo&lt;T&gt; for Bar
where
    T: Fn(&amp;(usize, usize)) -&gt; &amp;usize,
{
    fn foo(&amp;self, f: T) -&gt; &amp;usize {
        f(&amp;self.0)
    }
}

fn main() {
    let bar = Bar((5, 10));
    let x = bar.foo(|s| &amp;s.0);
    println!(&quot;{x}&quot;);
}</code></pre></pre>
<p>제네릭 <code>F</code> 타입의 파라미터 <code>f</code>를 갖는 <code>foo</code>를 갖는 트레잇 <code>Foo</code>와,
<code>(usize, usize)</code> 튜플 타입의 튜플을 받는 <code>Bar</code> 구조체가 구현되어있습니다.
아래에서 구현된 제네릭 <code>F</code>는 <code>Fn(&amp;(usize, usize)) -&gt; usize</code>로 트레잇 바운드를 해주었습니다.</p>
<p><code>foo</code> 함수는 인자 <code>f</code>를 실행하는 고차 함수입니다.
즉, <code>main</code> 함수에서 <code>foo</code>를 호출하여 <code>Bar</code>의 튜플에서 <code>0</code>번째 인덱스의 값을 가져오는 코드입니다.</p>
<h2 id="for-라이프타임"><a class="header" href="#for-라이프타임">for 라이프타임</a></h2>
<p>위 코드는 작동엔 문제 없으나, 어떠한 이유에서든 <code>F</code>에 수명을 명시하고 싶을 때가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>T: &lt;'a&gt; Fn(&amp;'a (usize, usize)) -&gt; &amp;'a usize
<span class="boring">}</span></code></pre></pre>
<p>하지만 이러한 코드는 작동하지 않습니다. 이럴 때 쓰이는 것이 <code>for&lt;'a&gt;</code>입니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>T: for&lt;'a&gt; Fn(&amp;'a (usize, usize)) -&gt; &amp;'a usize

// 또는

for&lt;'a&gt; T: Fn(&amp;'a (usize, usize)) -&gt; &amp;'a usize
<span class="boring">}</span></code></pre></pre>
<p>놀랍게도 이게 끝입니다. 심지어 <code>Fn</code> 계열 트레잇 외엔 많이 쓰이지도 않습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin과-unpin"><a class="header" href="#pin과-unpin">Pin과 Unpin</a></h1>
<p><code>Pin</code>은 <code>Pin&lt;T&gt;</code>에서 (<code>T</code>는 포인터) <code>T</code>가 가리키는 내용이 <code>Unpin</code>을 구현하지 않는 한 <code>T</code>가 이동되지 않도록 보장하는 스마트 포인터입니다.</p>
<p><code>T</code>는 이동(<code>move</code>)할 수 있는 포인터만 유효합니다. 만약 <code>T</code>가 <code>Unpin</code>을 구현하고 있다면, <code>Pin</code>이 비활성화 됩니다.
대부분 <code>Unpin</code>은 자동으로 구현됩니다. 물론 <code>PhantomPinned</code> 같은 경우엔 예외입니다.
<code>Pin</code>을 설명하기 전에, 이동에 대해 잠시 보도록 합시다:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);
    let s1 = s; // 이 시점에서 s는 유효하지 않다.
    println!(&quot;{}&quot;, s1);
}</code></pre></pre>
<p>이동(<code>move</code>)은 우리와 너무나도 친숙한 존재일겁니다.</p>
<p>이동은 러스트를 배우지 않았다면 불편한 존재지만, 러스트를 배우고 다시 보면 러스트의 자랑스러운 기능 중 하나 일 것입니다.
하지만 이런 이동이 일어나지 않아야 할 상황이 있습니다. 바로 **자기 참조 구조(<code>self reference structure</code>)**입니다:</p>
<pre><pre class="playground"><code class="language-rust">use std::ptr;

struct Foo {
    foo: usize,
    bar: *mut usize,
}

impl Foo {
    pub fn new(foo: usize) -&gt; Foo {
        Foo { foo, bar: ptr::null_mut() }
    }

    pub fn init(&amp;mut self) {
        self.bar = &amp;mut self.foo;
    }

    pub unsafe fn get_mut(&amp;self) -&gt; &amp;mut usize {
        &amp;mut *self.bar
    }
}

fn main() {
    let mut foo = Foo::new(1);
    foo.init();

    let foo_mut = unsafe { foo.get_mut() };

    *foo_mut = 5;
    println!(&quot;{}&quot;, foo_mut);
}</code></pre></pre>
<p>보통 이런 모습을 자기 참조 구조라 부릅니다.
위 코드에서 <code>get_mut()</code>은 <code>foo</code>의 참조가 아닌 <code>bar</code>에 저장해둔 참조를 반환합니다.
이 코드는 잘 작동하지만, 조금만 수정해봅시다:</p>
<pre><pre class="playground"><code class="language-rust">// 생략

fn foo() -&gt; Foo {
    let mut foo = Foo::new(1);
    foo.init();
    foo
}

fn main() {
    let f = foo();

    let foo_mut = unsafe { f.get_mut() };

    *foo_mut = 5;
    println!(&quot;{}&quot;, foo_mut);
}</code></pre></pre>
<p>이걸 실행해보면 이상한 값이 나오는데, <code>bar</code>가 <code>foo</code> 함수에서의 스택을 가리키고 있기 때문에, Undefined Behavior (UB) 가 발생합니다. 이미 해제된 메모리를 역참조하였기 때문이죠.</p>
<p>예를 들어, 어떤 객체가 <code>0x0001</code>에 위치해있고, 그 객체를 가리키는 포인터가 있다고 가정합시다.
만약 그 객체가 재배치 되어, 임의의 위치 <code>0x0002</code>로 이동하였다면 상당히 곤란하겠죠.
이 문제의 해결 방법은 이동해도 변하지 않는 주소일 때만 참조를 저장해야 합니다.</p>
<p><code>Pin</code>은 그 문제를 해결해줍니다:</p>
<h2 id="pin"><a class="header" href="#pin">Pin</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::{marker::*, pin::*, ptr};

struct Foo {
    foo: usize,
    bar: *mut usize,
    _pin: PhantomPinned,
}

impl Foo {
    pub fn new(foo: usize) -&gt; Foo {
        Foo { foo, bar: ptr::null_mut(), _pin: PhantomPinned }
    }

    pub fn init(self: Pin&lt;&amp;mut Self&gt;) {
        unsafe {
            let this = self.get_unchecked_mut();
            this.bar = &amp;mut this.foo;
        }
    }

    pub fn get_foo_mut(self: Pin&lt;&amp;mut Self&gt;) -&gt; Option&lt;&amp;mut usize&gt; {
        if self.bar.is_null() {
            None
        } else {
            unsafe { Some(&amp;mut *self.bar) }
        }
    }
}

fn foo() -&gt; Pin&lt;Box&lt;Foo&gt;&gt; {
    let foo = Foo::new(1);
    let mut foo = Box::pin(foo);

    foo.as_mut().init();
    foo
}

fn main() {
    let mut f = foo();

    let foo_mut = f.as_mut().get_foo_mut();

    if let Some(foo_mut) = foo_mut {
        *foo_mut = 5;

        println!(&quot;{}&quot;, *foo_mut);
    }
}</code></pre></pre>
<p>여기에서 <code>Foo</code> 구조체의 <code>_pin</code> 필드가 왜 존재하는지 의문일 수 있습니다.</p>
<p><code>marker</code> 타입 <code>PhantomPinned</code>를 사용하여 <code>Foo</code>를 <code>!Unpin</code>으로 만들어줍니다.
(<code>Send</code> 처럼 <code>!Send</code>를 구현할 수 있도록 하는 기능은 아직 지원하지 않습니다.)</p>
<p><code>Box&lt;T&gt;</code> 또한 <code>Unpin</code>이기 때문에, <code>Pin&lt;Box&lt;T&gt;&gt;</code>으로 래핑 하였습니다.
<code>Pin</code>을 사용한 타입들은 항상 고정된 주소를 가지게 되었고, <code>bar</code>도 <code>Pin</code>을 사용하여 초기화 되었습니다.
그렇기에 <code>Pin&lt;Box&lt;Foo&gt;&gt;</code>를 <code>Pin&lt;&amp;mut Foo&gt;</code> (<code>as_mut</code>)로 만드는 건 안전합니다.</p>
<p>추가적으로 <code>Pin&lt;T&gt;</code>을 사용할 때 조건이 있습니다:</p>
<ul>
<li><code>T</code>가 <code>Unpin</code>이면, <code>T</code>는 <code>Pin</code>에 의해 소멸될 때까지 <code>T</code>를 <code>Unpin</code> 상태로 유지해야 합니다.</li>
<li><code>T</code>가 <code>!Unpin</code>이면, <code>T</code>는 <code>Pin</code>에 의해 소멸될 때까지 고정됩니다.</li>
</ul>
<p><code>Unpin</code>을 구현하면 <code>Pin</code>이 <code>&amp;mut T</code>를 안전한 러스트에서 허용해주며, 그렇지 않으면 안전한 러스트에서 고정할 수 있습니다. (즉 <code>&amp;mut T</code>를 얻을 수 없음).</p>
<p>때문에 아래의 코드는 작동하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust">use std::{mem::*, pin::*};

fn swap_data&lt;T&gt;(x: Pin&lt;&amp;mut T&gt;, y: Pin&lt;&amp;mut T&gt;) {
    swap(&amp;mut *x, &amp;mut *y); // &lt;- cannot borrow data in dereference of `std::pin::Pin&lt;&amp;mut T&gt;` as mutable
}

fn main() {
    let mut x = 5;
    let mut y = 10;
    let x = Pin::new(&amp;mut x);
    let y = Pin::new(&amp;mut y);

    swap_data(x, y);
}</code></pre></pre>
<p>그럼 이런걸 어디에 쓸까요? 이는 <code>Future</code>에서 사용하는데 (사실상 여기서만 사용), <code>Future</code>은 이 글에서 자세히 다루진 않으나, 비동기에서 사용하는 중요한 개념입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rwlock-그리고-mutex의-차이점"><a class="header" href="#rwlock-그리고-mutex의-차이점">RwLock, 그리고 Mutex의 차이점</a></h1>
<p>한번쯤 들어본 <code>RwLock</code>은 <code>Mutex</code>(상호 배제)와 비슷해 보입니다.
<code>RwLock</code>는 <code>Reader-Writer Lock</code>의 줄임말입니다.</p>
<p><img src="https://media.githubusercontent.com/media/usagi/rust-memory-container-cs/master/1920x1080/rust-memory-container-cs-1920x1080-light-back-low-contrast.png" alt="image" />
(출처: https://github.com/usagi/rust-memory-container-cs)</p>
<p>이 자료에서 볼 수 있듯이 <code>Mutex</code>는 <code>Reader</code> / <code>Writer</code>이며, <code>RwLock</code>은 <strong><code>Readers</code></strong> / <code>Writer</code> 입니다.<br />
<code>Mutex</code>는 동기화이며, <code>RwLock</code>은 그렇지 않습니다. 여기서 <code>Lock</code>의 의미는 다음과 같습니다:</p>
<ul>
<li><code>Write Lock</code>: <code>Writer</code>가 쓰기를 마칠 때까지 <code>Reader</code>가 읽을 수 없습니다.</li>
<li><code>Read Lock</code>: <code>Reader</code>가 읽을 때 까지 <code>Writer</code>가 값을 수정할 수 없습니다.</li>
</ul>
<p><code>Mutex</code>는 <code>lock</code>을 호출하는 시점에서 자신의 차례가 올 때까지 기다립니다.
(<code>unlock</code>, <code>lock</code> 함수가 반환하는 <code>MutexGuard</code>가 <code>Drop</code> 되면 자동으로 <code>unlock</code> 됩니다.)</p>
<p>또 한가지가 더 있습니다.</p>
<p><code>RwLock&lt;T&gt;</code>는 <code>Mutex&lt;T&gt;</code>에 비해 <code>T</code>가 <code>thread-safe</code>를 위해 구현해야 할 트레잇 바운드가 더 많습니다:</p>
<ul>
<li><strong><code>Mutex</code>:</strong> <code>T: Send</code></li>
<li><strong><code>RwLock</code>:</strong> <code>T: Send + Sync</code></li>
</ul>
<p>즉, 동기화를 위한 API는 <code>Mutex</code>가 유일합니다.
<code>Mutex</code>와 <code>RwLock</code>의 API를 보면 차이점이 이해될 수 있습니다:</p>
<ul>
<li><code>Mutex</code>에서 값을 <code>Write</code>/<code>Read</code> (이하 <code>R/W</code>) 하려면 <code>lock</code>을 호출하여 <code>MutexGuard</code> 스마트 포인터를 얻습니다.<br />
이를 역참조하여, 값을 <code>R/W</code> 할 수 있습니다.
<ul>
<li><code>MutexGuard</code>는 <code>Deref</code>가 구현되어 있으니 스마트 포인터입니다. (이런 구조를 <code>RAII</code> 패턴이라 칭합니다.)<br />
즉, 정확히는 <code>Mutex</code>가 스마트 포인터가 아닌 <code>MutexGuard</code>가 스마트 포인터입니다.</li>
</ul>
</li>
<li><code>RwLock</code>은 <code>write()</code>와 <code>read()</code>를 통해 각각 <code>RwLockWriteGuard</code>와 <code>RwLockReadGuard</code>를 얻습니다.<br />
이 둘도 위와 같이 스마트 포인터 이며, 이들도 역참조를 통해 값을 <code>R/W</code> 할 수 있습니다.</li>
</ul>
<blockquote>
<p>물론 <code>lock()</code>, <code>write()</code>, <code>read()</code>를 호출하면 <code>Result&lt;T, E&gt;</code>를 반환합니다. 이해를 돕기 위해 위와 같이 설명했을 뿐이죠.</p>
</blockquote>
<p>아래의 예제를 보며, <code>Mutex</code>와 <code>RwLock</code>이 어떻게 작동하는지 확인해봅시다:</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::{Arc, Mutex},
    thread,
    time::Duration,
};

fn main() {
    let x = Arc::new(Mutex::new(0));

    let t1 = thread::spawn({
        let x = Arc::clone(&amp;x);

        move || {
            let mut x = x.lock().unwrap();
            *x += 1;

            println!(&quot;t1 (write): {}&quot;, *x);

            thread::sleep(Duration::from_secs(1));
        }
    });

    let t2 = thread::spawn({
        let x = Arc::clone(&amp;x);

        move || {
            let x = x.lock().unwrap();
            println!(&quot;t2: {}&quot;, *x);

            thread::sleep(Duration::from_secs(1));
        }
    });

    let t3 = thread::spawn({
        let x = Arc::clone(&amp;x);

        move || {
            let x = x.lock().unwrap();
            println!(&quot;t3: {}&quot;, *x);

            thread::sleep(Duration::from_secs(1));
        }
    });

    t1.join().unwrap();
    t2.join().unwrap();
    t3.join().unwrap();
}</code></pre></pre>
<p>이 예제는 <code>Mutex</code>를 사용하는 예제입니다.</p>
<p>실행해보면 <code>t1</code>이 출력되며, 1초를 기다린 후 <code>t2</code>, 또다시 1초를 기다린 후 <code>t3</code>가 출력되었습니다
이는 <code>Mutex</code>가 동기화라는 것을 알 수 있습니다. <code>R/W</code>를 하나 밖에 하지 않기 때문에 <code>lock</code>을 호출하여 <code>MutexGuard</code> 스마트 포인터를 가져온 후, 역참조 하여 값을 수정하고 읽었습니다.</p>
<h2 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h2>
<p>조금만 수정하여 <code>RwLock</code>을 사용하는 예제를 작성해봅시다:</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::{Arc, RwLock},
    thread,
    time::Duration,
};

fn main() {
    let x = Arc::new(RwLock::new(0));

    let t1 = thread::spawn({
        let x = Arc::clone(&amp;x);

        move || {
            let mut x = x.write().unwrap();
            *x += 1;

            println!(&quot;t1 (write): {}&quot;, *x);

            thread::sleep(Duration::from_secs(1));
        }
    });

    let t2 = thread::spawn({
        let x = Arc::clone(&amp;x);

        move || {
            let x = x.read().unwrap();
            println!(&quot;t2: {}&quot;, *x);

            thread::sleep(Duration::from_secs(1));
        }
    });

    let t3 = thread::spawn({
        let x = Arc::clone(&amp;x);

        move || {
            let x = x.read().unwrap();
            println!(&quot;t3: {}&quot;, *x);

            thread::sleep(Duration::from_secs(1));
        }
    });

    t1.join().unwrap();
    t2.join().unwrap();
    t3.join().unwrap();
}</code></pre></pre>
<p>이 예제를 실행해보면 <code>t1</code>이 출력된 후, 1초 뒤에 동시에 <code>t2</code>, <code>t3</code> (이 둘의 순서는 상관없습니다. 동시에 출력되었기 때문이죠.)이 출력되었습니다.
그리고 1초 후 프로그램이 종료되었습니다. 이렇듯 <code>RwLock</code>은 동기화되지 않습니다.
실제로 같은 코드 내에서 <code>Mutex</code>의 <code>lock</code>을 동시에 실행하면, 데드락(<code>deadlock</code>)이 발생합니다:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let x = Arc::new(Mutex::new(0));

    {
        let x1 = x.lock().unwrap();
        let x2 = x.lock().unwrap();
    }
}</code></pre></pre>
<p>이 예제는 영원히 끝나지 않습니다.
하지만 예제를 <code>RwLock</code>을 사용하는 방법으로 변경하면, 프로그램이 정상적으로 끝나는 것을 확인할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, RwLock};

fn main() {
    let x = Arc::new(RwLock::new(0));

    {
        let x1 = x.read().unwrap();
        let x2 = x.read().unwrap();
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-타입과-ordering-열거형"><a class="header" href="#atomic-타입과-ordering-열거형">atomic 타입과 Ordering 열거형</a></h1>
<p>보통 빌드한 프로그램을 실행하면 인간이 느끼기엔 빠르게 느껴집니다. (항상 그런건 아닙니다.)</p>
<p>근데 컴퓨터(하드웨어)는 그렇지 않습니다:
특히 램(<code>RAM</code>)은 생각보다 느립니다. 실제로 봐도 CPU와 램은 떨어져있죠.</p>
<p>이들이 데이터를 주고받느라(사이클) 꽤 많은 사이클을 소비합니다. &lt;-- 이건 손해죠.</p>
<p><code>CPU</code>는 어떠한 연산을 1번만에 처리하는 반면, 램과 데이터를 주고받느라 여러 사이클을 돌려야 하기 때문입니다.</p>
<p>그럼 어떻게 해야할까요?: 램은 <code>CPU</code>에 박아 넣으면 됩니다. (물리적으로)
<code>CPU</code> 마다 다르겠지만, <code>CPU</code>의 구조는 대충 이렇게 생겼습니다:</p>
<ul>
<li><code>MC (Memory Controller)</code>: 램과 소통하는 역할입니다. 여기서 램 슬롯 등을 제어합니다.</li>
<li><code>Core</code>: <code>CPU</code>의 그 코어가 맞습니다.</li>
<li><code>Cache</code>: 우리가 찾던 <code>CPU</code>에 박혀있는 램입니다. (물리적으로 <code>Core</code> 보다 더 큰 사이즈를 가지고 있습니다.) (<code>L1</code>, <code>L2</code>, <code>L3</code> 등)</li>
<li>... 그리고 <code>misc</code> (<code>minimal instruction set computers</code>), <code>qpi</code> (<code>quick path interconnect</code>) 등이 있습니다. 우리가 알아야할 것은 아닙니다.</li>
</ul>
<p><code>Cache</code> (캐시) 부분을 봅시다: <code>L1</code>은 <code>8~64KB</code> 정도로 제한됩니다. <code>L2</code>와 <code>L3</code>는 이것보다 더 크며, <code>L3</code>는 <code>8MB</code> 정도 됩니다.</p>
<p>우리가 생각하는 <code>8GB</code> 정도의 램은 아닙니다. 그러니깐 이름이 캐시 메모리죠.
아무튼 캐시를 사용하면, 램의 사이클보다 더 적은 사이클로, 빠르게 처리할 수 있습니다.
CPU가 특정 주소의 데이터에 접근하면, 먼저 캐시에서 찾습니다.</p>
<p>있으면 그 값을 읽고 (<code>cache hit</code>), 없으면 램에 접근합니다. (<code>cache miss</code>)</p>
<p>그리고, 그 값을 캐시에 저장합니다.
그런데 캐시는 상당히 제한되어있습니다. 당연하겠지만, <code>CPU</code>는 자주 접근하는 주소를 모르기 때문에, 그냥 무식하게 다 찼으면 <code>CPU</code> 마다 다른 방식으로 처리합니다.</p>
<p>여기서 등장하는 다른 용어가 있습니다: <code>CPU</code> 파이프라이닝 (<code>pipelining</code>)입니다. 매우 간단하게 설명하자면, 병렬 처리를 위해 존재합니다</p>
<p>예를 들어, 4단계의 어떤 사이클이 있다고 생각합시다. 한 사이클을 돌고 다른 사이클을 실행하는 것 보단, 동시에 실행하는 것이 효율적일 것입니다.
방금 <code>CPU</code> 명령어 실행 사이클을 말했습니다. <code>CPU</code>의 명령어 실행 사이클은 다음과 같습니다:</p>
<ol>
<li><code>fetch</code>: 명령어를 읽음</li>
<li><code>decode</code>: 명령어 해석</li>
<li><code>execute</code>: 명령어 실행</li>
<li><code>write</code>: 결과를 씀</li>
</ol>
<p>또 이상한게 있습니다. 컴파일 시 명령어 재배치가 일어날 수 있습니다. 말 그대로, 명령어가 재배치가 되는 경우입니다.</p>
<p>아마 그 코드는, 재배치가 되던 안되던 같은 값을 반환하며, <code>CPU</code> 파이프라이닝을 효율적으로 하기 위해 명령어 재배치가 일어났을 것입니다.
(참고로 <code>godbolt</code> 같은 곳에서 이를 재현하려 하면, 명령어 재배치가 일어나지 않을 수 있습니다. 이는 <code>CPU</code> 마다 다릅니다.)</p>
<p>그런데 이렇게 지 마음대로 수정해버리면, 그것이 제대로 작동한다는 보장이 있을까요? 이를 해결하기 위해, 수정 순서(<code>modification order</code>)가 존재합니다. 이는 어떤 값에 대한, 값의 변화를 기록합니다.</p>
<p>예를 들어, 변수 <code>foo</code>를 선언하고, 3개의 스레드 <code>A</code>, <code>B</code>, <code>C</code>를 동시에 실행합니다.</p>
<ul>
<li><code>A 스레드</code>: <code>foo</code>에 <code>1</code>을 대입. 그리고 약간의 딜레이 후, <code>foo</code>에 <code>2</code>를 대입: 이때의 수정 순서는 <code>1 -&gt; 2</code>가 됩니다.</li>
<li><code>B 스레드</code>: <code>foo</code>에 <code>3</code>을 대입. 그리고 <code>foo</code>를 <code>2</code>번 읽음: 이때의 수정 순서는 <code>3 -&gt; 4 -&gt; 2</code>가 됩니다.</li>
<li><code>C 스레드</code>: <code>foo</code>를 읽음. 그리고 <code>foo</code>에 <code>4</code>를 대입. 그리고 <code>foo</code>를 읽음: 이때의 수정 순서는 <code>1 -&gt; 4 -&gt; 2</code>가 됩니다.</li>
</ul>
<p>좀 복잡하게 설명했지만, 우리가 볼 것은 다음과 같습니다:</p>
<p>만약 어떤 스레드가 <code>3</code>을 읽었다면, 다음엔 <code>3</code>, <code>4</code>, <code>2</code> 중 하나가 읽합니다.
위에서 서술하지 않는 내용이 있는데, 바로 캐시는 코어마다 가지고 있습니다. (ex, <code>Core 1</code>의 <code>L1</code>, <code>L2</code>, <code>L3</code>)</p>
<p>만약 캐시에서만 <code>3</code>을 기록하고 있다면, 다른 코어에선 그 값이 <code>3</code> 인 것을 보장할 수 없습니다.
즉, 동기화 작업은 리소스가 시간을 많이 소비하는 작업입니다.</p>
<h2 id="atomic"><a class="header" href="#atomic">atomic</a></h2>
<p>서론이 좀 길었는데, 본론으로 돌아와 <code>atomic</code>에 대해 알아봅시다.</p>
<p>C++를 배워보았다면, <code>atomic</code>을 어느 정도 알 것입니다. 사실상 러스트의 <code>atomic</code>은 C++의 <code>atomic</code>을 구현한 것입니다.
<code>atomic</code>은 원자적 연산 (한 번에 일어나는 명령어 연산) 입니다. 1개의 명령어 이므로, 처리했다와 안했다로만 존재합니다.</p>
<p>(어셈블리어 코드에 <code>lock</code> 접두어가 포함되게 되는데, <code>lock</code>은 <code>CPU</code> 명령어 실행 사이클을 한번에 처리합니다.)</p>
<p><code>atomic</code>을 사용하는 예제:</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::{atomic::*, *},
    time::*,
    *,
};

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let t = {
        let spinlock_clone = Arc::clone(&amp;spinlock);

        thread::spawn(move || {
            while spinlock_clone.load(Ordering::Relaxed) == 1 {
                hint::spin_loop();

                thread::sleep(Duration::from_secs(2));

                spinlock_clone.store(3, Ordering::SeqCst);
            }
        })
    };

    while spinlock.load(Ordering::SeqCst) != 3 {
        hint::spin_loop();

        if spinlock.load(Ordering::SeqCst) == 3 {
            println!(&quot;{}&quot;, spinlock.load(Ordering::SeqCst));
        }
    }

    t.join().unwrap();
}</code></pre></pre>
<blockquote>
<p><code>Spin Lock</code>은 다른 스레드가 어떤 리소스를 <code>Lock</code> 하고 있다면, 현재 스레드를 기다리고, 락이 풀리면 현재 스레드가 그 리소스에 접근하는 동기화 기법입니다. 자세한 내용은 이 글에서 다루지 않습니다.</p>
</blockquote>
<h2 id="ordering"><a class="header" href="#ordering">Ordering</a></h2>
<p>위 코드에서 처음 보는 것들이 많이 등장했습니다: 바로 <code>Ordering</code> 열거형입니다.</p>
<ul>
<li><code>Relaxed (store, load, modify)</code>: 가장 느슨한 조건입니다. 즉, 다른 메모리 접근들과 순서가 바뀌어도 무방합니다. 아무런 제약이 없으므로, <code>CPU</code> 마음대로 재배치가 가능합니다. (결과가 동일하다면)</li>
<li><code>Release (store, modify), Acquire (load, modify)</code>: <code>Relaxed</code>는 아무런 제약이 없어서, 사실상 <code>Atomic</code>을 쓸 이유가 없어집니다. <code>Release</code>와 <code>Acquire</code>는 그것보단 조금 더 엄격합니다: <code>Release</code>는 재배치를 금지합니다. <code>Acquire</code>로 읽는다면, <code>Release</code> 이전의 명령어들이 스레드에 의해 관찰될 수 있어야 합니다.</li>
<li><code>AcqRel (modify)</code>: <code>Acquire</code> + <code>Release</code></li>
<li><code>SeqCst (store, load, modify)</code>: <code>SeqCst</code>는 순차적 일관성(<code>Sequential Consistency</code>)을 보장합니다. 쉽게 말해서 재배치도 없고 모든 스레드에서 동일한 값을 관찰할 수 있습니다. 대신 동기화 비용이 클 수 있습니다.</li>
</ul>
<p>또한, <code>store</code>와 <code>load</code> 함수는 <code>atomic</code> 객체에 대해 쓰기 및 읽기를 가능케 하는 함수입니다. 이 함수의 인자에 <code>Ordering</code> 열거형이 전달됩니다.</p>
<hr />
<p>그런데 우린 의문점이 하나 있습니다: <a href="https://github.com/rust-lang/rfcs/pull/1505">&quot;왜 <code>Atomic</code>은 제네릭(<code>Atomic&lt;T&gt;</code>)을 사용하지 않는가?&quot;</a> 이겠죠.</p>
<p>C++에서도 클래스 템플릿을 사용하여, <code>atomic</code>을 제네릭으로 사용할 수 있습니다. (<code>atomic&lt;T&gt;</code>)
그 이유는 생각보다 간단한데, 예를 들어, <code>Atomic&lt;[usize; 3]&gt;</code> 같은 건 하드웨어가 지원하지 않습니다.</p>
<p>이것의 해결법은 <a href="https://github.com/Amanieu/atomic-rs"><code>atomic</code> 크레이트</a>나 <code>Mutex&lt;T&gt;</code>를 사용하는 방법이 있습니다. 물론 둘 모두 <code>Atomic</code>의 작동 방식과는 다르긴 합니다.</p>
<p><code>Atomic</code>은 하드웨어와 동시성 프로그래밍을 둘 다 이해하고 있어야 함으로, 상당히 어려운 개념에 속합니다.</p>
<p>이해하지 못했다면, 그냥 <a href="rust/advanced/./rwlock.html"><code>Mutex&lt;T&gt;</code>나 <code>RwLock&lt;T&gt;</code></a>을 쓰는것이 올바른 선택입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repr-속성"><a class="header" href="#repr-속성">#[repr(...)] 속성</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: i32,
    y: i16
}
<span class="boring">}</span></code></pre></pre>
<p>얼핏 보기엔 <code>Foo</code>의 크기는 6바이트 (32비트 + 16비트 (= 48비트))가 되야하지만, 실제론 8바이트가 됩니다.</p>
<p>이는 구조체가 메모리 상에 어떻게 저장되는지 알아야하는데, 결론부터 말하자면 6바이트가 아닌 8바이트가 되는 이유는 메모리 상에서 패딩을 적용하기 때문입니다.</p>
<p>패딩은 <code>NULL</code> 데이터가 삽입된것이며, 최대 크기인 <code>x</code> (32비트 = 4바이트)의 크기와 맞추기위해 <code>y</code>에 3 바이트(=24비트)의 패딩이 삽입되었습니다. 즉, <code>y</code>의 크기는 4바이트가 되었습니다.</p>
<p>이렇게 패딩을 넣어주는것이 <strong>메모리 정렬</strong>인데, 메모리 정렬이 필요한 이유는 <code>CPU</code>에 있습니다.</p>
<p>컴퓨터는 데이터를 쓰거나 읽을때, 워드(<code>WORD</code>) 단위로 처리됩니다.
<code>CPU</code> 마다 다르긴 하지만, <code>1 WORD</code>는 4바이트를 가집니다. 즉, 컴퓨터는 메모리를 4바이트 단위로 처리하죠.
처음에 본 <code>Foo</code> 구조체를 살펴봅시다.</p>
<h2 id="첫번째-경우-원본-6-바이트"><a class="header" href="#첫번째-경우-원본-6-바이트">첫번째 경우: 원본 (6 바이트)</a></h2>
<blockquote>
<p><code>x</code> <strong>32비트</strong> + <code>y</code> <strong>16비트</strong> (= <strong>48비트</strong> = <strong>6바이트</strong>)</p>
</blockquote>
<p>만약 <code>Foo</code>의 데이터들이 <code>0x03</code> 부터 <code>0x08</code> 까지 메모리에 저장되어 있다고 가정해봅시다.</p>
<pre><code>00 01 02 03 | 04 05 06 07 | 08 09 0A 0B | 0C 0D 0E 0F
         └──────────────────┘
</code></pre>
<p><code>CPU</code>는 데이터를 처리하려면 <code>WORD</code> (= 4바이트) 단위로 처리해야합니다. 때문에 <code>CPU</code>는 총 3번의 메모리 접근을 해야합니다.</p>
<h2 id="두번째-경우-패딩-적용-8-바이트"><a class="header" href="#두번째-경우-패딩-적용-8-바이트">두번째 경우: 패딩 적용 (8 바이트)</a></h2>
<blockquote>
<p><code>x</code> <strong>32비트</strong> + <code>y</code> (<strong>16비트</strong> + <strong>패딩 16비트</strong> (= <strong>32비트</strong>)) (= <strong>64비트</strong> = <strong>8바이트</strong>)</p>
</blockquote>
<p>이 경우엔 데이터가 정렬되었고, 때문에 메모리 상에 다음과 같이 저장됩니다.</p>
<pre><code>00 01 02 03 | 04 05 06 07 | 08 09 0A 0B | 0C 0D 0E 0F
              └───────────────────────┘
</code></pre>
<p>이 경우엔 <code>CPU</code>는 총 2번의 메모리 접근을 해야합니다.</p>
<p>이처럼 위와같은 상황에선 두번째의 경우가 더 효율적입니다.
즉, 정렬을 위해선 <code>1 WORD</code>의 배수 크기로 데이터를 저장하면 됩니다. 즉, 구조체의 크기는 구조체에서 가장 큰 데이터의 크기의 배수가 됩니다.</p>
<h2 id="repr-속성-1"><a class="header" href="#repr-속성-1">#[repr(..)] 속성</a></h2>
<p><code>#[repr(..)]</code>은 구조체 또는 열거형의 메모리 레이아웃을 지정할 수 있는 속성입니다.</p>
<p>메모리 레이아웃은 크기, 정렬, 패딩 등이 포함됩니다.</p>
<ul>
<li><code>#[repr(C)]</code>: C/C++의 레이아웃을 따릅니다. 이는 FFI를 사용할때 유용합니다.</li>
<li><code>#[repr(packed)]</code>: 패딩을 하지 않습니다. 이는 메모리 절약을 위해 사용되나, 앞서 말한 메모리 정렬이 필요한 상황에선 부정적인 영향이 있을 수 있습니다.</li>
<li><code>#[repr(transparent)]</code>: 타입의 레이아웃을 필드 타입의 레이아웃으로 설정합니다. 필드는 하나만 제공되어야하며, <code>ZST</code> (<code>Zero Sized Type</code>)가 아니어야 합니다.</li>
<li><code>#[repr(align(n))]</code>: 타입의 정렬을 <code>n</code>으로 설정합니다. <code>n</code>은 2의 거듭제곱이어야 합니다.</li>
<li><code>#[repr(u*)]</code>, <code>#[repr(i*)]</code>: 필드가 없는 열거형의 크기를 지정합니다. <code>*</code> 은 <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code> 입니다.</li>
</ul>
<p>하나의 예시로, <code>#[repr(u8)]</code>을 사용하여, 열거형의 크기를 1바이트로 지정할 수 있습니다.</p>
<h3 id="repru8"><a class="header" href="#repru8">#[repr(u8)]</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum Color {
    Red,
    Green,
    Blue,
}

impl From&lt;Color&gt; for u8 {
    fn from(color: Color) -&gt; u8 {
        unsafe { std::mem::transmute(color) }
    }
}

let color = Color::Red;
let value: u8 = color.into();

assert_eq!(value, 0);
<span class="boring">}</span></code></pre></pre>
<h3 id="reprtransparent"><a class="header" href="#reprtransparent">#[repr(transparent)]</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
struct Wrapper&lt;T&gt;(T);

assert_eq!(4, std::mem::size_of::&lt;Wrapper&lt;i32&gt;&gt;());
assert_eq!(1, std::mem::size_of::&lt;Wrapper&lt;u8&gt;&gt;());
<span class="boring">}</span></code></pre></pre>
<p>자세한 내용은 <a href="https://doc.rust-lang.org/nomicon/other-reprs.html">nomicon</a> 참조.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lets-write"><a class="header" href="#lets-write">Let's write!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><code>Any</code> 트레잇에 대한 글은 <a href="https://ky0422.tistory.com/15">이곳</a>을 참고해봅시다.</p>
</blockquote>
<p><code>HashMap</code>을 쓰던 Rusty한 하루였습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HashMap::from([(1, 2), (3, 4)]);
<span class="boring">}</span></code></pre></pre>
<p><code>from</code> 함수를 사용해서(또는 <code>.into()</code>) <code>HashMap</code>을 생성할 수 있었습니다.</p>
<p>해시 맵이 아닌 <code>json</code> (<code>JavaScript Object Notation</code>) 값을 다루려면 <a href="https://github.com/serde-rs/json"><code>serde-rs/json</code></a> 등으로 <code>json</code> 값을 다룰 수 있습니다.</p>
<p>필자는 단순한 코드를 원하고, 크레이트를 사용하기 원하지 않았죠.
하지만 러스트에선 자바스크립트 계열 언어(타입스크립트 등)에 존재하는 <code>json</code> 기능이 없습니다.
(자바스크립트도 원래는 <code>JSON</code>이 기본 기능이 아니긴 했습니다.)</p>
<p>그래서 만능 매크로를 선언 해보았습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! json {
    ($($key:expr =&gt; $value:expr),*) =&gt; {{
        use std::collections::*;

        let mut map: HashMap&lt;&amp;str, _&gt; = HashMap::new();
        $(
            map.insert($key, $value);
        )*

        map
    }};
}
<span class="boring">}</span></code></pre></pre>
<p><code>key: value</code> 으로 작성했으면 좋겠지만, 파서의 한계로 <code>=&gt;</code> 를 사용하였습니다.</p>
<blockquote>
<p>만약 <code>serde-rs/json</code> 같은 크레이트와 같은 매크로를 선언하고 싶다면, <a href="https://ky0422.tistory.com/20">절차적 매크로를 사용해봅시다.</a></p>
</blockquote>
<p>이 매크로는 다음과 같이 사용할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>json! {
    &quot;a&quot; =&gt; &quot;foo&quot;,
    &quot;b&quot; =&gt; &quot;bar&quot;,
    &quot;c&quot; =&gt; &quot;baz&quot;
};
<span class="boring">}</span></code></pre></pre>
<p>사실 <code>json</code>이 아닌 <code>HashMap</code>이긴 합니다.
그런데 이것은 <strong>심각한</strong> 문제가 있습니다: 매크로에서 <code>value</code> 타입을 <code>&amp;str</code>로 단정 짓는 바람에 다른 타입을 쓸 수 없었습니다:</p>
<pre><code>json! {
    &quot;a&quot; =&gt; &quot;foo&quot;,
    &quot;b&quot; =&gt; &quot;bar&quot;,
    &quot;c&quot; =&gt; 3 // mismatched types
};
</code></pre>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<p>이러면 의미가 없으니, 필자는 <strong><code>Any</code></strong> 트레잇을 사용해보았습니다.
<code>Any</code> 트레잇은 모든 타입을 받을 수 있습니다. <code>Any</code> 트레잇은 <code>TypeId</code>와 같이 자주 사용되지만, 이 글에선 다루지 않습니다.
좀 복잡해질 수 도 있기 때문에 <code>json 모듈</code>을 따로 구현해두었습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod json {
    #[macro_export]
    macro_rules! json {
        ($($key:expr =&gt; $value:expr),*) =&gt; {{
            use std::{any::*, collections::*};

            let mut map: HashMap&lt;&amp;str, Box&lt;dyn Any&gt;&gt; = HashMap::new();
            $(
                map.insert($key, Box::new($value));
            )*
            map
        }};
    }
}

let json = json! {
    &quot;a&quot; =&gt; 1,
    &quot;b&quot; =&gt; &quot;qwerty&quot;,
    &quot;c&quot; =&gt; json! {
        &quot;d&quot; =&gt; [1, 2, 3]
    }
};
<span class="boring">}</span></code></pre></pre>
<p>이제 드디어 모든 타입을 받을 수 있게 되었습니다.</p>
<p><code>Any</code> 트레잇은 컴파일 시간에 크기를 알 수 없기 때문에, <code>Box&lt;T&gt;</code>를 사용하였습니다.
이제 <code>downcast_ref</code> 또는 <code>downcast_mut</code>으로 값에 접근할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(v) = json[&quot;b&quot;].downcast_ref::&lt;&amp;str&gt;() {
    assert_eq!(*v, &quot;qwerty&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="값-가져오기"><a class="header" href="#값-가져오기">값 가져오기</a></h2>
<p>그런데 누가 <code>json</code> 값을 가져오는데 <code>downcast_...</code>같은 복잡한 함수를 쓸까요? 그런건 아무도 안씁니다.
때문에 <code>get</code> 헬퍼 함수 및 가변 <code>downcast</code> 헬퍼 함수 <code>get_mut</code>을 구현해보았습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod json {
    use std::any::*;

    pub struct JsonValue&lt;T: Any + ?Sized&gt;(pub T);

    impl JsonValue&lt;dyn Any&gt; {
        pub fn get&lt;T: Any&gt;(&amp;self) -&gt; Option&lt;&amp;T&gt; {
            self.0.downcast_ref::&lt;T&gt;()
        }

        pub fn get_mut&lt;T: Any&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
            self.0.downcast_mut::&lt;T&gt;()
        }
    }

    #[macro_export]
    macro_rules! json {
        ($($key:expr =&gt; $value:expr),*) =&gt; {{
            use std::{any::*, collections::*};

            let mut map: HashMap&lt;&amp;str, Box&lt;JsonValue&lt;dyn Any&gt;&gt;&gt; = HashMap::new();
            $(
                map.insert($key, Box::new(JsonValue($value)));
            )*
            map
        }};
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>JsonValue</code> 구조체를 정의해주었습니다.
제네릭 <code>T</code>는 <code>Any</code>를 바운드하였으며, 컴파일 타임에 알 수 없기 때문에 <code>?Sized</code>를 붙여주었습니다.</p>
<p>코드는 복잡해 보이지만, 한층 더 편리한 러스트 프로그래밍을 할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use json::*;

let json = json! {
    &quot;a&quot; =&gt; 1,
    &quot;b&quot; =&gt; &quot;qwerty&quot;,
    &quot;c&quot; =&gt; json! {
        &quot;d&quot; =&gt; [1, 2, 3]
    }
};

if let Some(v) = json[&quot;b&quot;].get::&lt;&amp;str&gt;() {
    assert_eq!(*v, &quot;qwerty&quot;);
};

if let Some(v) = json.get_mut(&quot;b&quot;) {
    if let Some(v) = v.get_mut::&lt;&amp;str&gt;() {
        *v = &quot;foo&quot;;

        assert_eq!(*v, &quot;foo&quot;);
    }
};
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="번외"><a class="header" href="#번외">번외</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust가-c를-대체할-수-있을까"><a class="header" href="#rust가-c를-대체할-수-있을까">Rust가 C++를 대체할 수 있을까?</a></h1>
<p>IT 관련 뉴스를 보다 보면, Rust (러스트) 언어가 자주 언급되는 것을 볼 수 있습니다. 그런 기사를 보면, 여러 기업 (<code>Google</code>, <code>AWS</code> 등)과 프로젝트(<code>Deno</code>, <code>Redox</code> 등)의 개발 언어가 C++에서 Rust로 대체 또는 사용된다는 내용을 볼 수 있습니다. (심지어 Linux 커널에도 러스트가 도입되는 계획이 있습니다.)</p>
<p>아마 <code>&quot;Rust vs C++&quot;</code>가 주제인 논쟁이 자주 벌어지는 이유는, 두 언어의 사용처가 비슷하기 때문이겠죠.
이번 글은 러스트는 C++ 대신 사용하기 좋으며, 정말로 C++를 대체할 수 있을까? 에 대한 글입니다.</p>
<p>들어가기 앞서, 필자는 C++ 전공이 아니기 때문에 틀린 정보가 있을 수 도 있습니다. 이에 대해 반박하셔도 좋습니다.</p>
<p>러스트를 접해보았다면, C++과 상당히 비슷한 부분이 상당히 존재한다는 것을 알 수 있습니다.
안전한 러스트에선 전반적으로 <code>RAII</code> (<code>Resource Acquisition Is Initialization</code>) 패턴을 사용합니다.
이는 C++에서 유래되었습니다.</p>
<h2 id="안전한-러스트"><a class="header" href="#안전한-러스트">안전한 러스트</a></h2>
<p>여기서 안전한 러스트는 다음과 같은 보장을 말합니다:</p>
<ul>
<li>소유권과 참조, 수명을 컴파일 타임에 검사합니다.
<ul>
<li>소유권과 수명은 러스트의 가비지 컬렉터를 대신하여, 메모리 관리를 위해 고려된 생소한 개념입니다. (C++에도 <code>unique_ptr</code> 등의 소유권 개념이 있긴 합니다만.)</li>
<li>* 소유권과 수명을 이 글에선 서술하지 않습니다. 모든 값은 소유권과 수명을 가지고 있고, 이의 유효성을 컴파일 타임에 검사함으로써, 런타임 시 안전성을 보장한다는 것만 알아둡시다.</li>
<li>참조는 후술할 로우 포인터에 몇가지 안전성을 보장하는 시스템을 적용한 러스트의 기능입니다. 최종적으로는 로우 포인터로 컴파일됩니다.</li>
</ul>
</li>
<li><code>null</code>이 없습니다. (= <code>null pointer</code> 에러가 없습니다.)</li>
<li>가변성을 컴파일 타임에 검사합니다. 불변의 변수는 수정이 불가능하며, <code>mut</code> 키워드를 통해 가변 변수를 선언할 수 있습니다.</li>
<li>예외 대신 <code>Result&lt;T, E&gt;</code>를 사용합니다. (패닉(<code>panic</code>)이 존재하나, 디버그 (또는 테스트)가 아니라면, 프로그래머의 잘못이 아닌 이상 발생하진 않습니다.)</li>
</ul>
<h2 id="안전하지-않은-러스트"><a class="header" href="#안전하지-않은-러스트">안전하지 않은 러스트</a></h2>
<p>러스트가 안전하기만 하다고 서술하지 않고, 안전한 러스트라 서술한 이유는, 고급 기능인 안전하지 않는 (<code>unsafe</code>) 러스트가 존재하기 때문입니다.</p>
<p>안전하지 않는 러스트는 다음과 같은 기능을 가집니다.</p>
<ul>
<li>로우 포인터(<code>raw pointer</code>)를 역참조 할 수 있습니다. (= <code>null</code>이 발생할 수 있습니다.)</li>
<li>안전하지 않는 함수 호출할 수 있으며, 안전하지 않는 트레잇을 구현할 수 있습니다.</li>
<li>가변 정적 변수를 수정할 수 있습니다. (여기선 다루지 않습니다.)</li>
</ul>
<p>즉, 러스트는 메모리 안전을 보장으로 하나, 이를 강제하지 않는 안전하지 않는 러스트를 가지고 있습니다.
이 글은 러스트의 <code>unsafe</code>를 다루는 내용은 아니니, 이렇게 2가지의 러스트가 있다는 것만 알아둡시다.
또한 러스트는 C++의 거의 모든 (언어 레벨, 표준 라이브러리) 기능을 가지고 있습니다.</p>
<p>예를 들어, C++의 <code>shared_ptr</code>은 러스트의 <code>Rc&lt;T&gt;</code> (가변일 경우 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 등), <code>thread-safe</code>에서 사용할 경우 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 또는 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>) 등이 있습니다.</p>
<p>이를 바탕으로 C++와 러스트를 비교해봅시다:</p>
<h2 id="러스트의-특징과-단점"><a class="header" href="#러스트의-특징과-단점">러스트의 특징과 단점:</a></h2>
<ul>
<li>위에서 설명했듯이, (안전한 러스트에서) 메모리 안전을 보장합니다.</li>
<li>가비지 컬렉터가 없습니다.</li>
<li><code>null</code>이 없습니다.</li>
<li>병렬 프로그래밍, 함수형 프로그래밍, 시스템 프로그래밍을 지원합니다.</li>
<li><code>Cargo</code>라는 패키지 매니저로, 강력한 패키지 관리를 지원합니다.</li>
<li>C++에 비해, 문서(자료)가 많이 없습니다.</li>
<li>생태계가 C++에 비해 매우 작습니다.</li>
</ul>
<h2 id="c의-특징과-단점"><a class="header" href="#c의-특징과-단점">C++의 특징과 단점:</a></h2>
<ul>
<li>C 언어의 절차적 프로그래밍을 기반으로 객체지향 프로그래밍, 템플릿 등을 사용하는 일반화 프로그래밍을 지원합니다.</li>
<li>러스트와 반대로, 문서(자료)가 많으며, 한국어 자료 또한 매우 많아서, 자료를 참고하기 좋습니다.</li>
<li>생태계가 상당히 구축되어있습니다.</li>
<li>러스트에 비해 메모리 관리가 어렵습니다 (메모리 안전을 보장하지 않습니다.) (물론 스마트 포인터 <code>unique_ptr</code> (러스트의 소유권과 유사), <code>RAII</code> 패턴 등을 이용하면 어느 정도 방지할 수 있긴합니다만,)</li>
<li>생산성이 안 좋으며, 디버깅 및 유지보수가 힘듭니다.</li>
<li>이렇다 할 패키지 매니저가 없습니다. (컴파일러가 러스트 처럼 단일하지 않습니다.)</li>
</ul>
<p>둘 모두 서술되어있는 항목보다 더 많을 수도 있습니다.
이렇게만 보면, 러스트가 훨씬 좋아 보이는데, 그런데도 왜 아직까지 러스트보다 C++이 더 많이 쓰이는 걸까요?</p>
<h2 id="러스트의-생태계"><a class="header" href="#러스트의-생태계">러스트의 생태계</a></h2>
<p>위에서 말한 대로, 러스트는 C++에 비해 생태계가 매우 매우 작습니다. 이 뜻은 문서(자료), 커뮤니티 등이 C++에 비해 부족하다는 뜻이며, 결국 이는 이번 주제 (C++ vs Rust)에서 결정적인 증거가 됩니다.</p>
<p>여러 러스트 사용자들이 생태계를 구축하기 위해, 노력하고 있긴합니다.</p>
<p>당장 한국만 해도 <a href="https://rust-kr.org/">한국 러스트 사용자 그룹</a>, <a href="https://rinthel.github.io/rust-lang-book-ko/">Rust Book 한국어 번역</a> 등의 노력이 보이긴 하나, C++에 비빌정도는 택도 안됩니다.</p>
<h2 id="절대-c를-대체할-수-없는-것일까"><a class="header" href="#절대-c를-대체할-수-없는-것일까">절대 C++를 대체할 수 없는 것일까?</a></h2>
<p>그럼 러스트는 절대 C++를 대체할 수 없는 것일까요? 이건 또 아닙니다.</p>
<p>C++는 사실상 완벽한 생태계를 가지고 있고, 러스트는 생태계를 구축하는 중입니다.</p>
<p>이 뜻은 러스트가 C++를 충분히 대체할 수 있다는 얘기와 같습니다.
생태계가 작긴 하지만, 러스트는 표준 라이브러리 및 언어 문서화가 상당히 잘 되어있습니다.</p>
<p>그럼 영어도 능숙하게 할 수 있고, 메모리 안전성도 보장하고 싶으니, 러스트를 쓰겠다고 하는 사람도 분명 있겠죠.
언어의 선택은 본인의 자유이며, 언어마다 각자 장단점이 있긴 하지만, 러스트와 C++에 대해 한 가지만 말하고 글을 끝내겠습니다.</p>
<p>러스트는 메모리 안전을 보장으로 합니다. 하지만 그것에 완벽하다는 것은 아닙니다:</p>
<p>또한 C++은 발표된 지 무려 37년이 넘은 언어입니다. (러스트는 첫 릴리즈가 12년 전)
그런데도 메모리 안전성을 보장하지 않는 C++를 37년이 넘게 써왔습니다.</p>
<p>결국 이것은 프로그래머들이 큰 문제없이 써왔다는 것이며, 이는 곧 프로그래머에 따라, 메모리 안전을 보장할 수 있다는 뜻으로 해석할 수 있습니다.
C++가 잘못된 언어가 아납니다. 러스트가 완벽한 언어는 아니며, 모든 언어는 장단점을 가지고 있습니다.</p>
<p>대기업 또는 큰 프로젝트에서 러스트로 대체한다는 건, 러스트의 장점에 반한 경우이며, 아직 C++로 작성되어있는 (또는 작성될) 프로젝트는 이보다 더 많습니다.
(심지어 러스트로 대체한다는 계획을 절대 세우지 않는 프로젝트도 있을 겁니다.)</p>
<p>지금 당장은 러스트는 C++를 대체하기엔 어렵습니다. 하지만, 앞으로의 상황을 우린 알지 못합니다.
언젠간 러스트의 생태계가 커지고, C++를 대체하는 날이 올 수 도 있을겁니다.</p>
<p>이 주제에 대해 중립을 띄고 싶다면, 둘다 배워두시는 것도 좋은 방법입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>not available</p>
<div style="break-before: page; page-break-before: always;"></div><p>해당 문서의 일부는 <a href="http://ky0422.tistory.com/">ky0422 티스토리 블로그</a>의 일부 글을 옮겨왔습니다.</p>
<hr />
<p>모든 컨텐츠는 <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> 라이센스를 따릅니다.</p>
<hr />
<p>빠른 이해를 돕기 위해, 상황에 따라 일부 코드를 생략합니다. 예를 들어 아래와 같은 코드는</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Foo(i32, i32);

fn main() {
    println!(&quot;{:?}&quot;, Foo(1, 2));
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 생략

println!(&quot;{:?}&quot;, Foo(1, 2));
<span class="boring">}</span></code></pre></pre>
<p>등으로 표시할 수 있습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
